--     Camera perspective match mover for MAX
--
-- A utility for tracking features in a movie associated with points in a MAX scene
-- and deriving the real camera move & parameters.  The utility components:
--
-- 1. Movie				lets you select the movie file and enable display & auto save.
--						can set pixel aspect ratio.
-- 2. Motion Trackers	Lets you add any number of feature trackers to the movie.
--						Each tracker has a number, an associated scene object, an
--						active frame range and some sampling & control parameters.
--           			The section has a listbox of current trackers showing frame range
--                      object name & tracker number.  A switch lets you filter just the
--                      trackers active at the time slider pos.
--						Each tracker also has a persistent motion path buffer that contains
--  					it's tracked moves.  This may be saved & loaded to a text file.  It
--						also has an associated status vector, one for each tracked position
--					    that indicates whether the positon has been tracked, is empty, has
--                      been invalidated or has a user-forced value.
--						For each tracker you can enabled/disable, set resampling threshold, 
--                      select sub-pixel sampling level, control resampling at forced positions,
--                      step to start & end of active range, through stored positions, to
--						forced positions, clear stored positions.
-- 3. Track				lets you perform an actual tracking, set track range, enable/disable 
--                      trackers, enable concurrent match move.  Can control over-all image
--                      filtering such as de-interlace, despeckle, up contrast, etc.  Can
--                      control match space: color, gray rank, color rank, etc.  Has a set of
--						step buttons so you can step forward & backward through a match.  Lets
--						you also set 
-- 4. Match Move        lets you select a camera and perform actual camera match move
--                      against stored tracker pos data.  Can control frame range & movie-
--                      to-animation frame pegging.  Can choose parameters to match or
--						what are fixed.  Can set match filtering such as max cam accels.
--                      Can perform post match smoothing on given params.
--                      Can perform a pre-match FOV estimation pass and then a fixed-FOV
--						match pass.  Can perform a bracketed set of passes for any
--                      given fixed param - stores each pass internally and can load 
--						each into camera on demand.
--						Can choose real-camera non-linearity.
--
-- Gizmo setup			In the image window, you can adjust feature tracker gizmos.
--						Only active gizmos show up.  Can adjust with mouse or nudge with 
--					    cursor keys.  Can zoom in for acurate setting; if sub-pixel
--					    tracking enabled, can set feature bounds & center at sub-pixel res.
--
--
--

utility camtrack "Camera Tracker" silentErrors noCloseButton hidden
(
    local movie,		-- the current movie file
		  dot_mot,		-- the .mot tracker data file name for this movie
		  ct, mt,		-- holds the current tracker & low-level movie tracker
		  trackers,		-- the array of tracker structs for this movie
		  match_cam,	-- the match camera...
		  match_cam_name,
		  pin_obj, trkr,
		  err_scan_frame, -- current scan frame #
		  err_thresh = 0.05, cv_thresh = 0.4, jump_thresh = 5.0,		-- erro thresh. values
		  use_match_err = true, use_cv_err = true, use_jump_err = true	-- error thresh. enables

	local load_state, save_state, reset_panels, maybe_save_state, 	-- fn & rollout forwards...
	      maybe_load_state, gizmos, track, match, stepper, error,
		  posdata, filter, objmove

	struct tracker		-- an array of these describes the current movie's trackers
	(
		track_obj,		-- associated scene object
		track_obj_name, -- pathname to object
		gizmo,			-- Bitmap's low level feature tracker
		start_frame,	-- active movie frame range...
		end_frame,
		path,			-- stored path vector: one per active frame: undefined, trackpoint or a keyframe
		enabled,		-- tracking enable flag
		resample,		-- resample-on-error enable
		subpixel_level,	-- sub-pixel tracking level, 0 = off, level = power of 2 zoom
		match_weight,	-- tracker weighting in cam match correlation
		index,			-- this tracker's index
		cur_keyframe,   -- start keyframe # for the frame we are currently at
		last_err_frame,	-- frame with last tracking error, used to cancel track if double errors
		double_error	-- track has had a double error, used to disable gizmo for current tracking
	)
	
	struct key_frame	-- keyframe elements in a tracker's path vector
	(
		center,			-- feature center
		f_bounds,		-- feature bounds
		m_bounds		-- motion bounds
	)
	
	struct track_point	-- track_point elements in a tracker's path vector
	(
		center,			-- feature center
		match_error,	-- tracking error
		cv_delta,		-- color variance delta
		jump			-- center jump from last frame
	)
	
	label l0 "CamTrack v0.5b"
--	label l1 "Copyright (c) Lyric Media 1997"
--	bitmap bm1 filename:"Lyrlogo.bmp"    -- "g:\\3dsmax\\maps\\Lyr1.bmp"

	-- utility global functions...

	fn min a b = if a < b then a else b
	fn round_to val n = (floor ((val * (10.0 ^ n)) + 0.5)) / (10.0 ^ n)
	fn sign x = if x >= 0 then 1 else -1	

	fn set_active_trackers frame = 
		for t in trackers do t.gizmo.active = frame >= t.start_frame and frame <= t.end_frame and not t.double_error
		
	fn reset_error_detect =
		for t in trackers do (t.double_error = false; t.last_err_frame = undefined)
			
 	fn compute_jump trkr pi =
	(
		-- computes jump for t-1 to t
		local p0 = trkr.path[pi], jump = 0.0
		if pi >= 2 then
		(
			local p1 = trkr.path[pi - 1]
			if classOf p1 == track_point or classOf p1 == key_frame then
				jump = (distance p1.center p0.center) / 256.0			
		)
		p0.jump = jump
	)
	
	fn rel_jump t pi j = -- compare jump with 5 frame moving average
	(
		if pi > 6 then 
		(
			local jump_sum = 0.0
			for i in pi-5 to pi-1 do
			(
				local p = t.path[i], pm1
				if classOf p == track_point then jump_sum += p.jump
				else if classOf p == key_frame then 
				(
					if i > 1 and (pm1 = t.path[i-1]; classOf pm1 == track_point or classOf pm1 == key_frame)
					then jump_sum += (distance p.center pm1.center) / 256.0
					else return 0.0
				)
				else return 0.0
			)
--if abs (j - jump_sum / 5.0) > 4 then format "%, avg=%, j=%, delt=%\n" (pi + t.start_frame - 1) (jump_sum / 5.0) j (abs (j - jump_sum / 5.0))
			abs (j - jump_sum / 5.0)
		)
		else 0.0
	)
		
	fn tracking_error t f =
	(
		local result = false
		if f >= t.start_frame and f <= t.end_frame then
		(
			local pi = f - t.start_frame + 1
			tp = t.path[pi]
			if classOf tp == track_point then
			( 
				-- check all chosen error thresholds
				if (use_match_err and tp.match_error >= err_thresh or
				 	use_cv_err and tp.cv_delta >= cv_thresh or
 					use_jump_err and rel_jump t pi tp.jump > jump_thresh) then
				(
--format "jmp % = %, " tp.jump (tp.jump > jump_thresh)
--format "me % = %, cv % = %\n" tp.match_error (tp.match_error >= err_thresh) tp.cv_delta (pos.cv_delta >= cv_thresh)
					result = true
				)
			)
		)
		result
	)

	rollout setmovie "Movie"
	(
		label mf "Movie file:" align:#left
		button movie_file "none" width:110 height:30
		button show_movie "Display movie" offset:[0,6] enabled:false width:110 height:20
		spinner show_frame "Show frame:" type:#integer range:[0, 0, 0] enabled:false align:#left
		label dl "Deinterlace:" align:#left offset:[0,4]
		dropdownList deint items:#("Off", "Odd", "Even") width:70 align:#right offset:[-5,-20]
	--	checkbutton filmback_crop "Set filmback cropping"
	--	checkbox show_movie "Display movie" checked:true align:#left
		checkbox fade_display "Fade display" align:#left
		checkbox auto_save "Auto Load/Save settings" checked:true align:#left
		button save "Save" enabled:false across:3 width:49 offset:[-6,0]
		button save_as "Save As" enabled:false width:49 offset:[4,0]
		button load "Load" enabled:false width:49 offset:[6,0]
		label dot_name "--"
		button close_tracker "Close"
	--	group "Pre-load frames"
	--	(
	--		spinner load_start "Load start:" type:#integer
	--		spinner load_count "Load count:" type:#integer
	--		button pre_load "Load Frames"
	--	)
		
	 	on setmovie close do
		(
			if movie != undefined do
			(
				maybe_save_state()
				close movie
			)
		)
		
	    on movie_file pressed do 
	    (
			-- open movie selection dialog
	        local new_movie = selectCTBitMap ()
	        if new_movie != undefined then
			(
				-- got one, save & close any previous one
				if movie != undefined then
				(
					maybe_save_state()
					close movie
				)
				-- set up display range & open display vfb if enabled
				movie = new_movie
				movie_file.text = fileNameFromPath movie.filename
				local mf = movie.numFrames - 1
				show_frame.range = [0, mf, 0]
				save.enabled = save_as.enabled = load.enabled = show_movie.enabled = show_frame.enabled = true
			    track.check_status.enabled = true
				match.movie_start.range = [0, mf, 0]
				match.frames.range = [0, (min mf animationRange.end)+1, (min mf animationRange.end)+1]
				match.start_match.enabled = match_cam != undefined
				objmove.movie_start.range = match.movie_start.range
				objmove.frames.range = match.frames.range
				-- compute the .mot filename for current movie
				local mfn = movie.filename
				dot_mot = getfilenamePath mfn + getfilenameFile mfn + ".mot"
				if auto_save.checked then
				(
					dot_name.text = getfilenameFile mfn + ".mot"
					-- load any saved state & tell the trackers panel
					load_state()
				)
				else
				(
					dot_mot = undefined
					dot_name.text = "--"
					reset_panels ()
				)
				gizmos.movie_selected true
				movie.deinterlace = case deint.selection of (1: off; 2: #odd; 3: #even)
			--	if show_movie.checked then
			--	(
					display movie
					movie.showTracks = true
					show_movie.enabled = show_frame.enabled = true
			--	)
			)
	    )
		
		on deint selected sel do if movie != undefined then 
			movie.deinterlace = case deint.selection of (1: off; 2: #odd; 3: #even)
			
		
		on pre_load pressed do
		(
			loadFrames movie load_start.value load_count.value
		)
	
		on show_movie pressed do if movie != undefined then
		(				
			movie.showTracks = true
			display movie
		)
		
		on old_show_movie changed checked do
			if movie != undefined then 
			(
				if checked then
				(
					display movie
					gotoFrame movie show_frame.value
					show_frame.enabled = true
				)
				else
				(
					close movie
					show_frame.enabled = false
				)
			)
		
		on fade_display changed val do setFade movie (if val then 0.6 else 1)
		
		on show_frame changed val do
	--		if show_movie.checked then stepper.step_to val track:false
			stepper.step_to val track:false
			
		on save pressed do save_state()
		
		on save_as pressed do 
		(
			local f = getSaveFileName caption:"Camtracker file" types:"Camtrack files(*.mot)|*.mot|"
			if f != undefined then
			(
				dot_mot = f
				dot_name.text = getfilenameFile dot_mot + ".mot"
				save_state ()
			)
		)
		
		on load pressed do
		(
			if trackers.count != 0 then
			(
				-- already something open, reset things
				maybe_save_state ()
				for i in 1 to movie.numtrackers do deleteTracker movie 1
				reset_panels ()
			)
			local f = getOpenFileName caption:"Camtracker file" types:"Camtrack files(*.mot)|*.MOT|All files|*.*|"
			if f != undefined then
			(
				dot_mot = f
				dot_name.text = getfilenameFile dot_mot + ".mot"
				load_state ()
				gizmos.movie_selected true
			)
		)
		
		on close_tracker pressed do closeCameraTracker () 
	)
	
	-- gizmos rollout
	
	rollout gizmos "Motion Trackers"
    (
--		label ls "Show:" align:#left
--		radiobuttons show_type labels:#("All", "Active") columns:2 align:#right offset:[5, -17]
		listbox tracker_list height:6
		button track_on "On"  across:4 height:18 width:30 offset:[-4,-2]
		button track_off "Off" height:18 width:30  offset:[-4,-2]
		button all_on "All" height:18 width:34  offset:[-2,-2]
		button all_off "None" height:18 width:34 offset:[8,-2]
		button new_tracker "New tracker" enabled:false width:100 offset:[0,3]
		button delete_tracker "Delete tracker" enabled:false width:100
		label cur_trkr

		group "Tracker Setup"
		(
			label tro "Scene object:" align:#left
			pickbutton pick_tracker "none" width:110 enabled:false
		--	label l2 "Active movie segment:" align:#left
		--	spinner start "Start frame:" type:#integer
		--	spinner end "End frame:" type:#integer
			spinner mm_weight "Match weight:" range:[0,10,1] fieldwidth:36 type:#integer offset:[0,3]
			spinner max_move "Max move/frame:" range:[0,1000,20] fieldwidth:36 type:#integer offset:[0,3]
			label rsl "Resample on error:" align:#left
			checkbox resamp checked:true offset:[-20,-18] align:#right
			label l3 "Subpixel tracking:" align:#left offset:[0,3]
			dropdownlist subpixel_lvl items:#("off", "1/2", "1/4", "1/8", "1/16", "1/32") width:45 align:#right offset:[0,-21]
			label kfl "Track range:" offset:[0,-4]
			button activate "Set start" enabled:false across:2 width:60 align:#center toolTip:"Set first active frame at current Stepper frame"
			button deactivate "Set stop" enabled:false width:60 align:#center toolTip:"Set last active frame at current Stepper frame"
		)
		
		fn tracker_list_string t = 
		(
			local objname = if t.track_obj == undefined then "<none>" else t.track_obj.name,
			      tick = if t.enabled then "x  " else "    "
			tick + (t.index as string) + ". " + objname + " " + (t.start_frame as string) +
				 " - " + (t.end_frame as string)
		)
		
		fn update_tracker_list =
		(
			tracker_list.items = for i in 1 to trackers.count collect
			(
				local t = trackers[i]
				t.index = i  -- reset indexes
				tracker_list_string t
			)
			if ct != undefined then 
				pick_tracker.text = if ct.track_obj == undefined then "none" else ct.track_obj.name
			objmove.tracker_list.items = for i in tracker_list.items collect substring i 4 100
			objmove.tracker_selected()
		)
		
		fn tracker_selected sel = 
		(
			if ct != undefined then showTrack ct.gizmo off
			ct = trackers[sel]
			if ct != undefined then
			(
				pick_tracker.text = if ct.track_obj == undefined then "none" else ct.track_obj.name
				resamp.checked = ct.resample
				mm_weight.value = ct.match_weight
				subpixel_lvl.selection = ct.subpixel_level
				mt = ct.gizmo
				mt.selected = true
				showTrack mt stepper.show_trk.checked
				cur_trkr.text = substring (tracker_list_string ct) 4 200
			)
			else
			(
				pick_tracker.text = "none"
				resamp.checked = true
				mm_weight.value = 20
				subpixel_lvl.selection = 1
				cur_trkr.text = ""
			)
			tracker_list.selection = sel
			pick_tracker.enabled = true
			delete_tracker.enabled = activate.enabled = deactivate.enabled = true
			stepper.live_cam.enabled = match_cam != undefined
			stepper.track_enable.enabled = stepper.show_trk.enabled = stepper.step_keys.enabled = true
			stepper.sync_anim.enabled = true
			stepper.startsel.enabled = stepper.prev10.enabled = stepper.prev.enabled = stepper.next.enabled = true
			stepper.next10.enabled = stepper.endsel.enabled = stepper.clear_to_end.enabled = true
	--		posdata.pdf.enabled = posdata.pdf_display.enabled = posdata.prev_key.enabled = posdata.next_key.enabled = true
	--		posdata.load.enabled = posdata.save.enabled = posdata.clear.enabled = posdata.clear_all.enabled = true
		)
		
		fn movie_selected state =
		(
			-- handle movie selection notification from setmovie rollout
			new_tracker.enabled = state
			stepper.movie_frame.enabled = state
			if state then 
			(
				stepper.movie_frame.range = [0, movie.numFrames - 1, 0]
				[0, movie.numFrames - 1, movie.numFrames - 1]
				if trackers.count >= 1 then tracker_selected 1
				reset_error_detect ()
				set_active_trackers 0 
				update_tracker_list ()
			)
			else
			(
				stepper.movie_frame.range = [0, 0, 0]
			)
		)
		
		fn tracker_change_handler index event =
			-- handle tracker gizmo changes from bitmap system
			if event == #selected then
			(
				tracker_selected index
			)
			else if event == #changed then
			(
				-- gizmo moved by hand, plant keyframe & clear any saved positions up to next key frame
				local t = trackers[index]
				mt = getTracker movie index
				local kf = key_frame mt.center mt.featureBounds mt.motionBounds,
				      pi = movie.frame - t.start_frame + 1,
					  p = t.path
				-- plant new keyframe and clear up until next one if not doing a live match
				p[pi] = kf
				if not stepper.live_cam.checked then
					for i = pi + 1 to p.count do
						if classOf p[i] != key_frame then p[i] = undefined else exit
				t.cur_keyframe = movie.frame
				invalTrack mt FALSE
				-- do a live camera match if enabled
				if stepper.live_cam.checked and gizmos.check_objs movie.frame movie.frame then
				(	
					local objs = for t in trackers collect t.track_obj, err
					sliderTime = match.anim_start.value + (movie.frame - match.movie_start.value)
					animate match.anim_enabled.checked
						err = perspectiveMatch movie match_cam objs 2500 0x02 (match.chan_mask()) 
					match.pixerr.text = (round_to err 2) as string
				)
			)
		
		fn check_objs sf ef = 
		(
			-- make sure we have all active tracking objects in given frame range
			for t in trackers do
			(
				if t.track_obj == undefined and (sf >= t.start_frame and sf <= t.end_frame or
				                                 ef >= t.start_frame and ef <= t.end_frame) then 
				(
					messageBox ("Tracker " + t.index as string + " does not have an associated scene object.")
					return false
				)
				if sf != ef then 
				(
					-- check to ensure we have tracking data in the match range
					local csf = if sf < t.start_frame then t.start_frame else sf,
					      cef = if ef > t.end_frame then t.end_frame else ef,
					      pif = csf - t.start_frame + 1, pit = cef - t.start_frame + 1
					for pi in pif to pit do if t.path[pi] == undefined then 
					(
						messageBox ("Tracker " + t.index as string + " is not completely tracked in the match frame range.")
						return false
					)
				)
			)
			true
		)
		
		on gizmos open do
		(
			trackers = #()
			ct = undefined
		)
		
		on track_on pressed do
			if ct != undefined then 
			(
				ct.enabled = ct.gizmo.visible = true
				tracker_list.selected = tracker_list_string ct
				update_tracker_list ()  -- do this for now in case scene obj names have changed
			)
		
		on track_off pressed do
			if ct != undefined then 
			(
				ct.enabled = ct.gizmo.visible = false
				tracker_list.selected = tracker_list_string ct
				update_tracker_list ()  -- do this for now in case scene obj names have changed
			)
		
		on all_on pressed do
		(
			for t in trackers do t.enabled = t.gizmo.visible = true
			update_tracker_list ()
		)
		
		on all_off pressed do
		(
			for t in trackers do t.enabled = t.gizmo.visible = false
			update_tracker_list ()
		)
		
		on new_tracker pressed do
		(
			local mt = CTMotionTracker movie tracker_change_handler, c,
			      t = tracker start_frame:movie.frame				\
			                  end_frame:(movie.numframes - 1)		\
							  gizmo:mt								\
							  enabled:false							\
							  resample:resamp.checked				\
							  subpixel_level:subpixel_lvl.selection \
							  match_weight:mm_weight.value
			c = mt.center; mm = if max_move.value < 15 then 25 else max_move.value + 10
			mt.motionBounds = #(c.x - mm * 256, c.y - mm * 256, c.x + mm * 256, c.y + mm * 256)
			t.path = #(key_frame mt.center mt.featureBounds mt.motionBounds)
			append trackers t
			t.index = trackers.count
			pick_tracker.enabled = delete_tracker.enabled = true
			pick_tracker.text = "none"
			mt.active = true
			mt.enabled = mt.visible = t.enabled = true
			mt.subpixelLevel = t.subpixel_level
			if ct != undefined then showTrack ct.gizmo off
			ct = t
			setStruct mt t
			showTrack mt stepper.show_trk.checked
			update_tracker_list()
			tracker_selected trackers.count
		)
		
		on delete_tracker pressed do
			if ct != undefined then
			(
				deleteTracker movie ct.index
				deleteItem trackers ct.index
				resetZoom movie
				local new_sel = if ct.index > trackers.count then trackers.count else ct.index
				tracker_list.selection = new_sel
				if new_sel > 0 then
					tracker_selected new_sel
				else
				(
 					ct = undefined  -- all trackers deleted
					delete_tracker.enabled = false
				)
				update_tracker_list()
			)
		
		on activate pressed do
		(
			-- set active range start frame & adjust path vector to cover
			local old_start = ct.start_frame
			ct.start_frame = movie.frame
			if ct.end_frame < ct.start_frame then ct.end_frame = ct.start_frame
			tracker_list.selected = tracker_list_string ct
			ct.gizmo.active = true
			-- adjust path vec bounds, plant new start keyframe
			local mt = ct.gizmo,
				  kf = key_frame mt.center mt.featureBounds mt.motionBounds
			if ct.start_frame == ct.end_frame then ct.path = #(ct.path[1])
			else if old_start > movie.frame then
			(
				-- earlier, add more to front
				local prep = #(kf)
				prep[old_start - movie.frame] = undefined
				ct.path = prep + ct.path
			) 
			else
			(
				-- later, trim front
				while ct.path.count > (ct.end_frame - ct.start_frame) + 1 do 
					deleteItem ct.path ct.path.count
				ct.path[1] = kf
			)
		)
		
		on deactivate pressed do
		(
			-- set active range end frame & adjust path vector to cover
			local old_end = ct.end_frame
			ct.end_frame = movie.frame
			if ct.start_frame > ct.end_frame then ct.start_frame = ct.end_frame
			tracker_list.selected = tracker_list_string ct
			-- adjust path vec bounds
			if ct.start_frame == ct.end_frame then ct.path = #(ct.path[1])
			else if old_end > movie.frame then
			(
				-- earlier, trim back
				while ct.path.count > (ct.end_frame - ct.start_frame) + 1 do 
					deleteItem ct.path ct.path.count
			) 
		)
		
		on pick_tracker picked obj do
		(
			pick_tracker.text = obj.name
			ct.track_obj = obj
			ct.track_obj_name = "$'" + ct.track_obj.name + "'"
			update_tracker_list()
		)
		
		on tracker_list selected sel do 
		(
			local last_ct = ct
			tracker_selected sel
			ct = trackers[sel]
			if ct == last_ct then
			(
				-- toggle enable if second or later click on this tracker
				ct.enabled = not ct.enabled
				tracker_list.selected = tracker_list_string ct
			)
		)
		
		on mm_weight changed val do if ct != undefined then ct.match_weight = val
		
		on resamp changed state do if ct != undefined then ct.resample = state

		on subpixel_lvl selected sel do
			if ct != undefined then 
			(
				local old_lvl = ct.subpixel_level
				ct.subpixel_level = ct.gizmo.subpixelLevel = sel
				if old_lvl != sel and ct.cur_keyframe != undefined then
				(
					if movie.frame != ct.cur_keyframe then
						stepper.step_to ct.cur_keyframe track:false 
			 		resample ct.gizmo
				)
			)
	)
	
    rollout stepper "Movie Stepper"
    (
		local pink = color 255 60 60
		spinner movie_frame "Movie frame:" type:#integer range:[0, 0, 0] enabled:false align:#left
		button startsel "<<" across:6 width:20 offset:[0,0] enabled:false toolTip:"Step to first active frame for selected tracker"
		button prev10 "<10 " width:26 offset:[4,0] enabled:false toolTip:"Step back 10 frames"
		button prev "< " width:20 offset:[4,0] enabled:false toolTip:"Step back 1 frame or keyframe"
		button next ">" width:20 offset:[3,0] enabled:false toolTip:"Step forward 1 frame or keyframe"
		button next10 ">10 " width:26 offset:[10,0] enabled:false toolTip:"Step forward 10 frames"
		button endsel ">>" width:20 offset:[12,0] enabled:false toolTip:"Step to last active frame for selected tracker"
		checkbutton track_enable "Off" width:32 offset:[11,0] highlightColor:pink checked:false enabled:false align:#left
		label etl "Feature tracking" offset:[17, -22]
	--	checkbox track_enable "Master track enable" checked:false offset:[16,0] enabled:false
		button clear_to_end "Clear tracking to end" offset:[0,5] enabled:false toolTip:"Clear all position data from current frame to end"
		checkbox step_keys "Step key-frames" checked:false offset:[16,0] enabled:false
		checkbox show_trk "Show track" checked:true offset:[16,0] enabled:false
		checkbox live_cam "Live camera match" checked:false offset:[16,0] enabled:false
		checkbox sync_anim "Sync animation" checked:false offset:[16,0] enabled:false
--		group "Range Limit"
--		(
--			spinner movie_start "Movie start:" type:#integer range:[0, 0, 0] fieldwidth:40
--			spinner frames "Frame count:" type:#integer range:[0, 0, 0] fieldwidth:40
--			button goto_start_btn "Goto start" enabled:false
--		)
--		checkbox enable_move "Concurrent match move" checked:false offset:[0,-6]

		-- stepper functions...

		fn resample_gizmo t f pi = 
			if pi > 0 and classOf t.path[pi-1] == track_point then
			(
				-- error found, resample back a frame, plant a keyframe there & retrack 
				local enableds = for ti in trackers collect (en = ti.gizmo.enabled; ti.gizmo.enabled = false; en)
--format "resamp % @ %\n" t.index f
			    gotoFrame movie (f - 1)
				t.gizmo.center = t.path[pi-1].center
				resample t.gizmo
				t.path[pi-1] = key_frame t.gizmo.center t.gizmo.featureBounds t.gizmo.motionBounds
				t.cur_keyframe = f - 1
				-- enable just this gizmo, retrack to current frame & store data
				t.gizmo.enabled = true
			    gotoFrame movie f
				t.path[pi] = track_point t.gizmo.center t.gizmo.error t.gizmo.cvDelta 
				compute_jump t pi
				-- re-enable appropriate gizmos
				for i in 1 to trackers.count do trackers[i].gizmo.enabled = enableds[i]
			)
			
		fn dump_tracking_error t f pi =
		(
			local tp = t.path[pi]
			format "tracking error in % @ %" t.index f
			case of
			(
				(use_match_err and tp.match_error >= err_thresh): format ", me: %" tp.match_error
			 	(use_cv_err and tp.cv_delta >= cv_thresh): format ", vd: %" tp.cv_delta
 				(use_jump_err and rel_jump t pi tp.jump > jump_thresh): format ", jd: %" (rel_jump t pi tp.jump)
			)
			format "\n"
		)

		fn snap_gizmo t f enable =
			if t.gizmo.active and t.enabled and not t.double_error then
			(
				local pi = f - t.start_frame + 1
				      pos = t.path[pi]
				if pos == undefined and enable then	-- record new pos if tracking enabled
				(
					t.path[pi] = track_point t.gizmo.center t.gizmo.error t.gizmo.cvDelta 
					compute_jump t pi 
					if tracking_error t f then
					(
						if t.last_err_frame == f - 1 then
							t.double_error = true
						else if t.resample then
							resample_gizmo t f pi
						t.last_err_frame = f
					)
				)
				else if classof pos == key_frame then  -- resample image if keyrame
				(
					resample t.gizmo
					t.cur_keyframe = f
				)
			)
						
		fn find_keyframe p pi dir =   -- find next keyframe in given direction from given path index
		(
			if dir > 0 then for i = pi to p.count by dir do if classOf p[i] == key_frame do return i
			else for i = pi to 1 by dir do if classOf p[i] == key_frame do return i
			undefined
		)
			
		fn set_gizmo t f enable =
		(
			t.gizmo.enabled = false  -- start out disabled
			if t.gizmo.active then
			(
				local pi = f - t.start_frame + 1
				      pos = t.path[pi]
				if pos == undefined then 			-- no stored pos, set enable status
					t.gizmo.enabled = enable and t.enabled and not t.double_error
				else if classof pos == track_point then  -- stored pos, move gizmo
					t.gizmo.center = pos.center
				else 								-- keyframe, set gizmo
				(
					t.gizmo.center = pos.center
					t.gizmo.featureBounds = pos.f_bounds
					t.gizmo.motionBounds = pos.m_bounds
				)
				-- resample feature if we moved out of current keyframe zone
				local zki = if classof pos == key_frame then pi else find_keyframe t.path pi -1,
				      zkf = zki + t.start_frame - 1
				if zkf != t.cur_keyframe then
				(
					resample t.gizmo zkf t.path[zki].center t.path[zki].f_bounds
					t.cur_keyframe = zkf
				)
			)
		)
		
		fn set_movie_frame movie f enable =
		(
			-- set movie at given frame
			-- condition gizmos, set movie frame, snap any new tracked pos's or keyframe resamples
			set_active_trackers f
			movie_frame.value = f
			for t in trackers do set_gizmo t f enable
		    gotoFrame movie f
			if sync_anim.checked then sliderTime = match.anim_start.value + (f - match.movie_start.value)
			for t in trackers do snap_gizmo t f enable
		)
		
fn show_pos =
if movie.frame >= ct.start_frame and classOf (pos = ct.path[movie.frame - ct.start_frame + 1]) == track_point then
(
format "% - %," movie.frame ct.gizmo.center
format "jmp % = %, " pos.jump (pos.jump > jump_thresh)
format "me % = %, cv % = %\n" pos.match_error (pos.match_error >= err_thresh) pos.cv_delta (pos.cv_delta >= cv_thresh)
)

		fn step_to frame track:true =
			if movie != undefined then
			(
				reset_error_detect ()
				if frame < 0 then frame = 0
				if frame > movie.numframes - 1 then frame = movie.numframes - 1
				if frame > movie.frame and track and track_enable.checked then
				(
				    local count = abs(frame - movie.frame), i = 0
					if count > 2 then progressStart "Tracking..."
					for f = movie.frame + 1 to frame by sign (frame - movie.frame) do
					(
						set_movie_frame movie f true
				        if count > 2 then if progressUpdate ((i += 1) * 100 / count) == false then exit
--show_pos()
					)
				    if count > 2 then progressEnd ()
				)
				else
					set_movie_frame movie frame false
			)
			
		fn step_to_key dir = 
		(
			local pi = dir + movie.frame - ct.start_frame + 1,
			      kfi = find_keyframe ct.path pi dir
			if kfi != undefined then step_to (ct.start_frame + kfi - 1) track:false
			else if dir > 0 then step_to ct.end_frame track:false
			else step_to ct.start_frame track:false
		)
		
		on startsel pressed do step_to ct.start_frame track:false

		on prev pressed do if step_keys.checked then step_to_key -1 else step_to (movie.frame - 1)

		on prev10 pressed do step_to (movie.frame - 10)

		on next pressed do if step_keys.checked then step_to_key 1 else step_to (movie.frame + 1)

		on next10 pressed do step_to (movie.frame + 10)

		on endsel pressed do step_to ct.end_frame
		
		on track_enable changed state do track_enable.text = if state then "On" else "Off"

		on clear_to_end pressed do
			if ct != undefined then
			(
				-- clear pos data to end
				invalTrack mt FALSE
				local pi = movie.frame - ct.start_frame + 1,
					  p = ct.path
				for i = pi + 1 to p.count do p[i] = undefined
				invalTrack mt TRUE
			)
		
		on movie_frame changed frame do step_to frame
		
		on show_trk changed state do if ct != undefined then showTrack ct.gizmo state
	)
	
    rollout error "Error Thresholds"
    (
		checkbox use_match_err_cb checked:use_match_err
		spinner err_thresh_sp "Match error:" fieldwidth:35 range:[0,5,err_thresh] offset:[-2,-20] scale:0.01
		checkbox use_cv_err_cb checked:use_cv_err
		spinner cv_thresh_sp "Variance delta:" fieldwidth:35 range:[0,10,cv_thresh] offset:[-2,-20] scale:0.01
		checkbox use_jump_err_cb  checked:use_jump_err
		spinner jump_thresh_sp "Jump delta:"  fieldwidth:35 range:[0,50,jump_thresh] offset:[-2,-20]

		on use_match_err_cb changed state do use_match_err = state
		on use_cv_err_cb changed state do use_cv_err = state
		on use_jump_err_cb changed state do use_jump_err = state

		on err_thresh_sp changed val do err_thresh = val
		on cv_thresh_sp changed val do cv_thresh = val
		on jump_thresh_sp changed val do jump_thresh = val
	)
	
    rollout track "Batch Track"
    (
		local errors
		
		button track_incompletes "Complete Tracking" width:114
		group "Tracking Status"
		(
			button check_status "Check status" width:114 enabled:false
			label status_1 "Incomplete: ?" align:#left
			label status_2 "Errors: ?" align:#left
		)
		group "Tracking error review"
		(
			listbox error_list height:6 width:140 align:#center
			-- label review "-- --"
			button next_err "Next" enabled:false across:2 width:60
			button clear_err "Clear" enabled:false width:60
		)

		-- track functions...
		
		fn round val n = 
		(
		    local mult = 10.0 ^ n
			(floor ((val * mult) + 0.5)) / mult
		)

		fn error_string t f =
		(
			local str = t.index as string + " @ " + f as string,
			      pi = f - t.start_frame + 1,
				  tp = t.path[pi]
			if use_match_err and tp.match_error >= err_thresh then
				str += ", me: " + (round tp.match_error 2) as string
			if use_cv_err and tp.cv_delta >= cv_thresh then
				str += ", vd: " + (round tp.cv_delta 2) as string
 			if use_jump_err and rel_jump t pi tp.jump > jump_thresh then 
				str += ", jd: " + (round (rel_jump t pi tp.jump) 2) as string
			str
		)

		fn build_err_list = 
		(
			local e_list = #()
			reset_error_detect ()
			errors = #()
			for f in 0 to movie.numFrames - 1 do
				for t in trackers do
					if tracking_error t f then
					(
						append e_list (error_string t f)
						append errors #(t, f)
					)
			error_list.items = e_list
			error_list.selection = 0
			clear_err.enabled = next_err.enabled = e_list.count > 0
		)
		
		fn sel_error i =
		(
			local err = errors[i]
			gizmos.tracker_selected err[1].index
			stepper.set_movie_frame movie err[2] false
		)

		-- track handlers...

		on check_status pressed do
		(
			-- get tracker status, incompletes & errors
			local incompletes = #(), errors = #()
			for t in trackers do
			(
				local u = findItem t.path undefined
				if u > 0 and u + t.start_frame <= t.end_frame or t.path.count < t.end_frame - t.start_frame + 1
					then append incompletes t
				for f in t.start_frame to t.end_frame do
					if tracking_error t f then (append errors t; exit)
			)
			local txt = "Incompletes: "
			if incompletes.count == 0 then txt += "none"
			else for i in 1 to incompletes.count do (if i != 1 then txt += ","; txt += incompletes[i].index as string)
			status_1.text = txt
			txt = "Errors: "
			if errors.count == 0 then txt += "none"
			else for i in 1 to errors.count do (if i != 1 then txt += ","; txt += errors[i].index as string)
			status_2.text = txt
			track_incompletes.enabled = incompletes.count != 0
			build_err_list ()
		)
		
		on error_list selected sel do sel_error sel
		
		on next_err pressed do
		(
			local next = error_list.selection + 1
			error_list.selection = if next > error_list.items.count then 1 else next
			sel_error error_list.selection
		)

		on clear_err pressed do if error_list.selection > 0 then
		(
			local sel = error_list.selection
			error_list.items = deleteItem error_list.items sel
			errors = deleteItem errors sel
			if sel <= error_list.items.count then sel_error sel
			else if error_list.items.count > 0 then (error_list.selection = (sel -= 1); sel_error sel)
			else next_err.enabled = clear_err.enabled = false
		)
		
		on track_incompletes pressed do
		(
			-- find untracked frames in enabled trackers & track 'em
			local frames = #(), first_frame
			-- first scan & build array of frames to track
			for f in 0 to movie.numFrames do
				for t in trackers where t.enabled do
					if f > t.start_frame and f <= t.end_frame then
					(
						if first_frame == undefined or f < first_frame then first_frame = f
						if t.path[f - t.start_frame + 1] == undefined then
						(
							append frames f
							exit
						)
					)

			-- now track them
			if frames.count > 2 then progressStart "Tracking..."
			reset_error_detect ()
			local last_f
			for i = 1 to frames.count do
			(
				local f = frames[i]
				-- position at run-up frame if there is a discontinuity
				if f > 0 and last_f != f - 1 then stepper.set_movie_frame movie (f - 1) false
				-- scan this frame
				stepper.set_movie_frame movie f true
				last_f = f
		        if frames.count > 2 then if progressUpdate ((i += 1) * 100 / frames.count) == false then exit
				-- check to see at least one actiev tracker is still enabled
				local none_still_enabled = true
				for t in trackers do if t.enabled and t.gizmo.active and not t.double_error then none_still_enabled = false
				if none_still_enabled then exit
			)
		    if frames.count > 2 then progressEnd ()
			-- reset back to earliest first frame of enabled trackers
			if first_frame != undefined then stepper.step_to first_frame track:false
		)
		
	)
	
    rollout posdata "Position Data"
	(
		group "Apply to"
		(
			radiobuttons applyto labels:#("Selected tracker", "Enabled trackers", "All")
		)
		
		button clear_to_end "Clear to end"  width:70 across:2 align:#left offset:[-6,0]
		button show "Show data"  width:70 align:#right offset:[6,0]
		button clear_all "Clear all"  width:70 across:2 align:#left offset:[-6,0]
		button export "Export"  width:70 align:#right offset:[6,0]
	--	button import "Import"  width:70 align:#right offset:[6,0] enabled:false

		on export pressed do
		(
		    format "% - %\n" ct.start_frame ct.end_frame
			for i in 1 to ct.path.count do format "%: %\n" (i+ct.start_frame-1) ct.path[i]
		)
		
		fn dump t df =
		(
			format "Tracker %\nTracking object %\n" t.index t.track_obj_name to:df
			format "Frame, Position x, y, Key Feature left, top, right, bot, Search l, t, r, b\n" to:df
			for i in 1 to t.path.count do
			(
				format "%, " (t.start_frame + i - 1) to:df
				local p = t.path[i]
				if classof p == track_point then
					format "%, %\n" (p.center.x/256.) (p.center.y/256.) to:df
				else if classof p == key_frame then
					format "%, %, %, %, %, %, %, %, %, %\n" (p.center.x/256.) (p.center.y/256.) 		\
						(p.f_bounds[1]/256.) (p.f_bounds[2]/256.) (p.f_bounds[3]/256.) (p.f_bounds[4]/256.)  \
						(p.m_bounds[1]/256.) (p.m_bounds[2]/256.) (p.m_bounds[3]/256.) (p.m_bounds[4]/256.) to:df
				else
					format "undefined\n" to:df
			)
			format "\n" to:df
		)
					
		on show pressed do
		(
			local ew = newScript ()
			case applyto.state of
			(
				1: if ct != undefined then dump ct ew
				2: for t in trackers where t.enabled do dump t ew
				3: for t in trackers do dump t ew
			)
		)

		on export pressed do
		(
			local efn = getSaveFileName caption:"Position data file" types:"Excel(*.csv)|*.csv|Data(*.dat)|*.dat|"
			if efn != undefined then
			(
				ef = createFile efn
				case applyto.state of
				(
					1: if ct != undefined then dump ct ef
					2: for t in trackers where t.enabled do dump t ef
					3: for t in trackers do dump t ef
				)
				close ef
			)
		)

		fn cte t =
		(
			local pi = movie.frame - t.start_frame + 1,
				  p = t.path
			for i = pi + 1 to p.count do p[i] = undefined
		)	

		on clear_to_end pressed do 
			if queryBox "Confirm clear to end" then
			(
				if ct != undefined then	invalTrack mt FALSE
				case applyto.state of
				(
					1: if ct != undefined then cte ct
					2: for t in trackers where t.enabled do cte t
					3: for t in trackers do cte t
				)
				if ct != undefined then	invalTrack mt TRUE
			)
			
		on clear_all pressed do 
			if queryBox "Confirm clear all data" then
			(
				if ct != undefined then	invalTrack mt FALSE
				case applyto.state of
				(
					1: if ct != undefined then ct.path = #(ct.path[1])
					2: for t in trackers where t.enabled do t.path = #(t.path[1])
					3: for t in trackers do t.path = #(t.path[1])
				)
				if ct != undefined then	invalTrack mt TRUE
			)
	)
		
	rollout match "Match Move"
	(
		local errors

		fn fcf obj = classOf obj == Freecamera

		label co "Camera:" align:#left
		pickbutton pick_cam "none" width:110 filter:fcf
		label l0 offset:[0,-10]
		
		group "Match"
		(
			checkbox m_fov "FOV" across:2 offset:[8,0] checked:true 
			checkbox m_roll "Roll" offset:[8,0] checked:true
			checkbox m_pan "Pan" across:2 checked:true offset:[8,0]
			checkbox m_tilt "Tilt" checked:true offset:[8,0]
			checkbox m_truck_h "Truck H." across:2 checked:true offset:[8,0]
			checkbox m_truck_v "Truck V." checked:true offset:[8,0]
			checkbox m_dolly "Dolly" checked:true offset:[8,0]
		)
		
	--	group "Tracker Weighting"
	--	(
	--		checkbox weights_on "Enable tracker weighting" checked:true
	--		checkbox auto_weight "Auto center weighting"
	--		spinner center_weight_amt "Amount:" type:#integer range:[0, 100, 20] enabled:false
	--	)
		
		group "Match Range"
		(
			spinner movie_start "Movie start:" type:#integer range:[0, 0, 0]
			spinner anim_start "Animation start:" type:#integer range:[0, 0, 0]
			spinner frames "Frame count:" type:#integer range:[0, 0, 0]
--			button goto_start_btn "Goto start" enabled:false
			button reset_ranges "Reset Ranges"
		)
		
		checkbox show_match "Animate Displays" checked:false offset:[10,0]
		checkbox anim_enabled "Generate Keyframes" checked:true offset:[10,0]
		button start_match "Match Move" width:100 offset:[0,5] enabled:false
		-- button step "Step"
		label pel "Max. pixel error:" across: 2
		label pixerr align:#left offset:[6,0]
	--	button delete_keys "Delete keyframes" enabled:false
	    button show_errs "Show errors" enabled:false width:85
		
		on match open do
		(
			anim_start.range = [animationRange.start, animationRange.end, animationRange.start]
			frames.range = [animationRange.start, animationRange.end + 1, animationRange.end + 1]
		)
		
		on pick_cam picked obj do 
		(
			match_cam = obj; pick_cam.text = obj.name
			match_cam_name = "$'" + obj.name + "'"
			stepper.live_cam.enabled = ct != undefined  -- enable live cam if we have a tracker selected
			start_match.enabled = movie != undefined
			filter.do_filt.enabled = true
		)
		
		fn set_centers f =
		(
			-- set active gizmos and there center for view correlation computation
			set_active_trackers f
			for t in trackers do if t.gizmo.active then
			(
				local pi = f - t.start_frame + 1
				      pos = t.path[pi]
				if classof pos == track_point then
					t.gizmo.center = pos.center
				else if classof pos == key_frame then
				(
					t.gizmo.center = pos.center
					t.gizmo.featureBounds = pos.f_bounds
					t.gizmo.motionBounds = pos.m_bounds
				)
			)
		)
		
		fn chan_mask = 
		(
			local mask = 0
			if m_fov.checked then mask += 0x0001
			if m_roll.checked then mask += 0x0002
			if m_pan.checked then mask += 0x0008
			if m_tilt.checked then mask += 0x0004
			if m_truck_h.checked then mask += 0x0010
			if m_truck_v.checked then mask += 0x0020
			if m_dolly.checked then mask += 0x0040
			mask
		)
		
		fn pre_delete_keys = 
		(
		)
		
		fn match_loop show_match = 
		(
			local objs = for t in trackers collect t.track_obj, err, max_err = 0.0
			movie.showTracks = false
			pixerr.text = ""
			errors = #()
			show_errs.enabled = true
			pre_delete_keys ()
			if show_match then stepper.set_movie_frame movie movie_start.value false
			progressStart "Matching..."
			escapeEnable = false
			undo on for i = 0 to frames.value - 1 do
			(
				local af = anim_start.value + i,
					  mf = af - anim_start.value + movie_start.value,
				      init_cam_pos = if i == 0 then 0x1000 else 0  -- init cam pos on first frame only
				if show_match then
				(
					stepper.set_movie_frame movie (movie_start.value + i) true
					sliderTime = af
				)
				else
					set_centers af
				
				animate match.anim_enabled.checked at time af
					err = perspectiveMatch movie match_cam objs 2500 0x02 (chan_mask() + init_cam_pos)
				
				append errors [af, mf, err]
				if err > max_err then
				(
					max_err = err
					pixerr.text = (round_to err 2) as string + " at " + mf as string
				)
				
				if err > 10 then 
				(
					local msg = "Errors too large at movie frame " + mf as string + ".  Continue matching?"
					if queryBox msg == false then exit
				)
		        if progressUpdate (i * 100 / frames.value) == false then exit
			)
		    progressEnd ()
			escapeEnable = true
			if not show_match then stepper.set_movie_frame movie (movie_start.value + frames.value - 1) false
			movie.showTracks = true
		)
		
		on start_match pressed do
			if match_cam != undefined and gizmos.check_objs movie_start.value (movie_start.value + frames.value)
				 do match_loop show_match.checked
		
		on movie_start changed val do
		(
			local fc = if movie == undefined then animationRange.end - anim_start.value + 1
					   else min (movie.numFrames - val) (animationRange.end - anim_start.value + 1),
			      fe = min fc frames.value
			frames.range = [0, fc, fe]
		)
		
		on anim_start changed val do
		(
			local fc = if movie == undefined then animationRange.end - anim_start.value + 1
					   else min (movie.numFrames - movie_start.value) (animationRange.end - val + 1),
			      fe = min fc frames.value
			frames.range = [0, fc, fe]
		)
		
		on reset_ranges pressed do 
			if movie != undefined then
			(
				-- reset to current movie/scene stats
				local mf = movie.numFrames - 1
				setmovie.show_frame.range = [0, mf, 0]
				movie_start.range = [0, mf, 0]
				frames.range = [0, (min mf animationRange.end)+1, min frames.value ((min mf animationRange.end)+1)]
				anim_start.range = [animationRange.start, animationRange.end, animationRange.start]
			)
			
		on show_errs pressed do 
		(
			local errw = newScript ()
			format "Match move errors for %\n\n" match_cam.name to:errw
			format "Movie  Animation  Pixel Error\n"s to:errw
			format "frame    frame\n"s to:errw
			for e in errors do format "  %        %        %\n" (e.x as integer) (e.y as integer) (round_to e.z 2) to:errw
		)
	)
	
	rollout filter "Move Smoothing"
	(
		group "Channel to smooth"
		(
			radiobuttons filt_btns columns:2 
				labels:#("Rotation", "Position", "Roll", "Truck H", "Pan", "Truck V", "Tilt", "Dolly", "FOV") default:9
		)
		group "Smooth type"
		(
			radiobuttons smooth_type labels:#("Straight line average", "Low pass filter") default:2
			spinner filt_amt "Smooth amount:" range:[0.1, 50, 3] fieldWidth:40 align:#right
		)
		group "Smooth range"
		(
			radiobuttons smooth_range labels:#("Match move range", "All frames") default:1
		)
		checkbox re_match "Re-match after smooth"
		button do_filt "Smooth" width:100 enabled:false
		
		fn normalize_kernel kernel =
		(
			local sum = 0
			for w in kernel do sum += w
			for w in kernel collect w as float / sum
		)
		
		fn gausian_kernel sigma scale:1.0 = 
		(
			local root2pi = sqrt (2 * pi), w = 2 * (1 + sigma as integer) - 1, knl = #()
			for i = 0 to w do 
			(
				local x = i * scale,
				      fx = (exp (((x / sigma)*(x / sigma)) / -2)) / (sigma * root2pi)
				knl[w + i + 1] = fx
				if i != 0 then knl[w + i + 1] = knl[w - i + 1] = fx
			)
			knl
		)
		
		fn key_range c r = 
		(
			local cr = getTimeRange c #allKeys,
			      st = if cr.start > r.start then cr.start else r.start,
			      et = if cr.end < r.end then cr.end else r.end
			#(getKeyIndex c st, getKeyIndex c et) 
		)
				
		fn straight_line c axis range = 
		(
			local tot, avg, k, keys = c.keys,
			      kr = key_range c range,
				  ks = kr[1], ke = kr[2],
				  ts = getKeyTime c ks, te = getKeyTime c ke,
				  kcount = 0
			for i in ks to ke do
			(
				local k = keys[i]
				if tot == undefined then tot = k.value 
				else tot += k.value
				kcount += 1
			)
			avg = tot / kcount
			if axis == unsupplied then 
			(
				-- place linear avg value keys at start and end
				local zero = if superClassOf c == PositionController then [0,0,0] else 0
				selectKeys c (interval ts te)
				deleteKeys c #selection
				addNewKey c ts; k = keys[getKeyIndex c ts]
				k.value = avg; k.outTangent = zero; k.outTangentType = #linear
				addNewKey c te; k = keys[getKeyIndex c te]
				k.value = avg; k.inTangent = zero; k.inTangentType = #linear
			)
			else
				for i in ks to ke do
				(
					local k = keys[i] 
					case axis of
					(
				        #x:  k.value.x = avg.x
			 			#y:  k.value.y = avg.y
						#z:  k.value.z = avg.z
					)
				)
		)
		
		fn filter ctrlr kernel range axis: =
			if smooth_type.state == 1 then straight_line ctrlr axis range
			else
			(
				local width = kernel.count, -- window width  
					  n_knl = normalize_kernel kernel,		
				      r = getTimeRange ctrlr,
					  keys = ctrlr.keys,
					  kr = key_range ctrlr range,
				      ks = kr[1], ke = kr[2],
					  sval = at time r.start ctrlr.value, 
					  eval = at time r.end ctrlr.value,
					  smoothed = #()
			
				for i in ks to ke do
				(
					local k = keys[i], t = k.time, kval = k.value, fval = kval - kval,
						  ts = t - width / 2
					for w in n_knl do 
					(
						local cval = at time ts ctrlr.value
						if ts < r.start then cval = sval - ((at time (r.start + (r.start - ts)) ctrlr.value) - sval)
						if ts > r.end then cval = eval - ((at time (r.end - (ts - r.end)) ctrlr.value) - eval)
						fval += cval * w
						ts += 1
					)
					append smoothed fval
				)
	
				for i in 1 to smoothed.count do
				(
					local ki = i + ks - 1
					case axis of
					(
					    unsupplied:  keys[ki].value = smoothed[i]
						        #x:  keys[ki].value.x = smoothed[i].x
					 			#y:  keys[ki].value.y = smoothed[i].y
								#z:  keys[ki].value.z = smoothed[i].z
					)
				)
			)
		
		on smooth_type changed state do filt_amt.enabled = state == 2
		
		on do_filt pressed do
		(
			-- check & adjust controllers
			local rc = match_cam.rotation.controller,
				  pc = match_cam.pos.controller,
				  pos_xyz = classOf pc == Position_XYZ,
				  knl = gausian_kernel filt_amt.value
			
			-- if rotation, make sure we have an EulerXYZ controller
			local fb = filt_btns.state
			if (fb == 1 or fb == 3 or fb == 5 or fb == 7) and classOf rc != Euler_XYZ then
			(	
				if queryBox "Rotation needs Euler XYZ controller.  Click Yes to change controller and then do a rematch." then
					match_cam.rotation.controller = rc = Euler_XYZ()
				else 
					return ok
			)
			-- compute the frame range
			local range =
				if smooth_range.state == 1 then interval match.anim_start.value (match.anim_start.value + match.frames.value) 
				else interval -1e6 1e6
			
			undo on case filt_btns.state of
			(
				1: -- all rotation channels
			  	(
					filter rc.x_rotation.controller knl range
					filter rc.y_rotation.controller knl range
					filter rc.z_rotation.controller knl range
					match.m_roll.checked = match.m_pan.checked = match.m_tilt.checked = false
				)
				2: -- all pos channels
				(
					if pos_xyz then 
					(
						filter pc.x_position.controller knl range
						filter pc.y_position.controller knl range
						filter pc.z_position.controller knl range
					)
					else
						filter pc knl range
					match.m_truck_h.checked = match.m_truck_v.checked = match.m_dolly.checked = false
				)
				3: (filter rc.y_rotation.controller knl range; match.m_roll.checked = false)
				5: (filter rc.z_rotation.controller knl range; match.m_pan.checked = false)
				7: (filter rc.x_rotation.controller knl range; match.m_tilt.checked = false)
				4: 
				(
					if pos_xyz then filter pc.x_position.controller knl range
					else filter pc knl range axis:#x
					match.m_truck_h.checked = false
				)
				6: 
				(
					if pos_xyz then filter pc.z_position.controller knl range 
					else filter pc knl range axis:#z
					match.m_truck_v.checked = false
				)
				8: 
				(
					if pos_xyz then filter pc.y_position.controller knl range
					else filter pc knl range axis:#y
					match.m_dolly.checked = false
				)
				9: (filter match_cam.fov.controller knl range; match.m_fov.checked = false)
			)
			-- re match camera with smoothed channels disabled
			if re_match.checked then match.match_loop false
		)
	)
	
	rollout objmove "Object Pinning"
	(
		--	local pin_obj, trkr
		
		dropdownList tracker_list "Choose tracker:"
		label otp "Object to pin:" align:#left
		pickbutton pick_pin "none" width:110 enabled:false
		group "Pin Range"
		(
			spinner movie_start "Movie start:" type:#integer range:[0, 0, 0]
			spinner anim_start "Animation start:" type:#integer range:[0, 0, 0]
			spinner frames "Frame count:" type:#integer range:[0, 0, 0]
			button reset_ranges "Reset Ranges"
	--		button goto_start "Goto Start"
		)
		
	    label psl "Pin space:" across:2 offset:[-5,0]
	    label pml "Pin mode:" offset:[-7,0]
		radiobuttons space labels:#("Screen  ", "Grid") default:1 columns:1 across:2
		radiobuttons mode labels:#("Absolute", "Relative") default:1 columns:1
		
		button pin "Pin" width:110 enabled:false
		
		fn tracker_selected =
		(
			local sel = tracker_list.selection,
			      force_pin = trkr != undefined and pin_obj != undefined and trkr.track_obj != pin_obj
			trkr = if sel > 0 then trackers[sel] else undefined
			if not force_pin then
			(
				pick_pin.text = if sel > 0 and trkr != undefined and trkr.track_obj != undefined then trkr.track_obj.name else "none"
				pin_obj = if sel > 0 and trkr != undefined then trkr.track_obj else undefined
			)
			pick_pin.enabled = sel > 0
			pin.enabled = pin_obj != undefined
		)
		
		fn set_pin_obj obj = 
		(
			pin_obj = obj
			pick_pin.text = if pin_obj != undefined then pin_obj.name else "none"
			pin.enabled = pin_obj != undefined
		)
		
		on tracker_list selected sel do tracker_selected ()
		
		on pick_pin picked obj do 
		(
			pin_obj = obj
			pick_pin.text = obj.name
			pin.enabled = pin_obj != undefined
		)
		
		on movie_start changed val do
		(
			local fc = if movie == undefined then animationRange.end - anim_start.value + 1
					   else min (movie.numFrames - val) (animationRange.end - anim_start.value + 1),
			      fe = min fc frames.value
			frames.range = [0, fc, fe]
		)
		
		on anim_start changed val do
		(
			local fc = if movie == undefined then animationRange.end - anim_start.value + 1
					   else min (movie.numFrames - movie_start.value) (animationRange.end - val + 1),
			      fe = min fc frames.value
			frames.range = [0, fc, fe]
		)
		
		on reset_ranges pressed do 
			if movie != undefined then
			(
				-- reset to current movie/scene stats
				local mf = movie.numFrames - 1
				movie_start.range = [0, mf, 0]
				frames.range = [0, (min mf animationRange.end)+1, min frames.value ((min mf animationRange.end)+1)]
				anim_start.range = [animationRange.start, animationRange.end, animationRange.start]
			)

		on goto_start pressed do
		(
			sliderTime = anim_start.value
		)
		
		on objmove open do
		(
			anim_start.range = [animationRange.start, animationRange.end, animationRange.start]
			frames.range = [animationRange.start, animationRange.end + 1, animationRange.end + 1]
		)
		
		fn mapTPosToView tpos z movie = 
		(
			local w2 = 0.5 * movie.width,
				  h2 = 0.5 * movie.height,
				  f = tan (0.5 * getViewFOV() * 180.0 / pi) * z / w2
 			[-(tpos.x - w2) * f, (tpos.y - h2) * f, z]
		)

		on pin pressed do
		(
			local vtm = getViewTM(),
				  vitm = inverse vtm,
				  cpitm = getCPTM(),
				  cptm = inverse cpitm,
				  offset
				  
			-- establish current frame offset if relative move
			if mode.state == 2 then  -- relative
			(
				local mf = movie_start.value + (sliderTime.frame - anim_start.value),
					  pi = mf - trkr.start_frame + 1
				-- make sure tracker pos data is there
				if pi < 1 or trkr.path[pi] == undefined then 
				(
					messageBox ("Missing tracker position data at frame " + mf as string)
					return ok
				)
				-- pick up screen pos (tracker pos is in 1/256th pixels)
				local tpos = trkr.path[pi].center / 256.0,
				      oz = (pin_obj.pos * vtm).z
				offset = 
					if space.state == 1 then  -- screen space
						pin_obj.pos * vtm - (mapScreenToView tpos oz [movie.width, movie.height])
					else
						pin_obj.pos * cptm - (mapScreenToCP tpos [movie.width, movie.height])
			)
			else
				offset = [0,0,0]
				
			-- loop over frames, planting pin object keyframes			
			undo on animate on
			for i in 0 to frames.value - 1 do
			(
				local mf = movie_start.value + i,
				      af = anim_start.value + i,
					  pi = mf - trkr.start_frame + 1
				-- make sure tracker pos data is there
				if pi < 1 or trkr.path[pi] == undefined then 
				(
					messageBox ("Missing tracker position data at frame " + mf as string)
					return ok
				)
				-- pick up screen pos (tracker pos is in 1/256th pixels)
				local tpos = trkr.path[pi].center / 256.0,
				      oz = (pin_obj.pos * vtm).z
				-- plant keyframe
				at time af
					pin_obj.pos = 
						if space.state == 1 then	-- screen space
							(offset + mapScreenToView tpos oz [movie.width, movie.height]) * vitm
						else
							(offset + mapScreenToCP tpos [movie.width, movie.height]) * cpitm
			)
		)
	)

	fn reset_panels =
	(
		trackers = #()
		ct = mt = match_cam = undefined
		gizmos.movie_selected true
	)
	
	fn maybe_save_state = if setmovie.auto_save.state and
							 queryBox "Do you want to save tracker state?" then save_state ()
	
	fn save_state =
	(
		-- saves tracker & setting details for this movie in a text file
		setmovie.dot_name.text = getfilenameFile dot_mot + ".mot"
		local f = createFile dot_mot
		-- dump version header & selected panel parameters
		format "Camtrack 0.5\n" to:f
		print match_cam_name to:f
		-- dump panel state
	--	format "% % % % " setmovie.show_movie.checked setmovie.fade_display.checked setmovie.auto_save.checked setmovie.deint.selection to:f
		format "% % % % " true setmovie.fade_display.checked setmovie.auto_save.checked setmovie.deint.selection to:f
		format "% % % %\n" gizmos.mm_weight.value gizmos.max_move.value gizmos.resamp.checked gizmos.subpixel_lvl.selection to:f
		format "% % % " error.use_match_err_cb.checked error.use_cv_err_cb.checked error.use_jump_err_cb.checked to:f
		format "% % %\n" error.err_thresh_sp.value error.cv_thresh_sp.value error.jump_thresh_sp.value to:f
		format "% % % " match.m_fov.checked match.m_roll.checked match.m_pan.checked to:f
		format "% % % %\n" match.m_tilt.checked match.m_truck_h.checked match.m_truck_v.checked match.m_dolly.checked to:f
		format "% % % " match.movie_start.value match.anim_start.value match.frames.value to:f
		format "% %\n" match.show_match.checked match.anim_enabled.checked to:f
		format "% % %\n" filter.filt_btns.state filter.filt_amt.value filter.re_match.checked to:f
		-- dump trackers
		format "%\n" trackers.count to:f
		for t in trackers do
		(
			print t.track_obj_name to:f
			format "% % " t.start_frame t.end_frame to:f
			format "% % % %\n" t.enabled t.match_weight t.resample t.subpixel_level to:f
			format "%\n" t.path.count to:f
			for p in t.path do
			(
				if classof p == key_frame then
				(
					format "k % % %\n" p.center p.f_bounds p.m_bounds to:f
			--		format "#(%, %, %, %) " p.f_bounds[1] p.f_bounds[2] p.f_bounds[3] p.f_bounds[4] to:f
			--		format "#(%, %, %, %)\n" p.m_bounds[1] p.m_bounds[2] p.m_bounds[3] p.m_bounds[4] to:f
				)
				else if p != undefined then
					format "p % % % %\n" p.center p.match_error p.cv_delta p.jump to:f
				else
				    format "u\n" to:f
			)
		)
		-- dump objmove
		format "% % %\n" objmove.movie_start.value objmove.anim_start.value objmove.frames.value to:f
		format "% " objmove.tracker_list.selection to:f
		if pin_obj != undefined
			then format "\"$'%'\"\n" pin_obj.name to:f
			else format "undefined\n" to:f
		format "% %\n" objmove.space.state objmove.mode.state to:f

		close f
	)
		
	fn maybe_load_state = if setmovie.auto_save.state then load_state ()
	
	fn load_state =
	(
		trackers = #()
		local f = openFile dot_mot
		if f != undefined then
		(
			-- load control params & trackers from file.  First check file tag & version
			if skipToString f "Camtrack " == undefined then
			(
				messageBox "Invalid .mot file"
				close f
				return ok
			)
			local version = readLine f
			if version == "0.4b" or version == "0.5" then
			(
				match_cam_name = readValue f
				match_cam = if match_cam_name != undefined then execute match_cam_name else endefined
				if match_cam != undefined and classOf match_cam == FreeCamera then 
				(
					match.start_match.enabled = movie != undefined
					filter.do_filt.enabled = true
					match.pick_cam.text = match_cam.name
				)
				-- load panel
		--		setmovie.show_movie.checked = readValue f
				readValue f
				setmovie.fade_display.checked = readValue f
				setmovie.auto_save.checked = readValue f
				setmovie.deint.selection = if version != "0.4b" then readValue f else 1
				gizmos.mm_weight.value = readValue f
				gizmos.max_move.value = readValue f
				gizmos.resamp.checked = readValue f
				gizmos.subpixel_lvl.selection = readValue f
				error.use_match_err_cb.checked = use_match_err = readValue f
				error.use_cv_err_cb.checked = use_cv_err = readValue f
				error.use_jump_err_cb.checked = use_jump_err = readValue f
				error.err_thresh_sp.value = err_thresh = readValue f
				error.cv_thresh_sp.value = cv_thresh = readValue f
				error.jump_thresh_sp.value = jump_thresh = readValue f
				match.m_fov.checked = readValue f
				match.m_roll.checked = readValue f
				match.m_pan.checked= readValue f
				match.m_tilt.checked = readValue f
				match.m_truck_h.checked = readValue f
				match.m_truck_v.checked = readValue f
				match.m_dolly.checked = readValue f
				match.movie_start.value = readValue f
				match.anim_start.value = readValue f
				match.frames.value = readValue f
				-- reset to current movie/scene stats
				local mf = movie.numFrames - 1
				setmovie.show_frame.range = [0, mf, 0]
				match.movie_start.range = [0, mf, min mf match.movie_start.value]
				match.frames.range = [0, (min mf animationRange.end)+1, min match.frames.value ((min mf animationRange.end)+1)]
				match.anim_start.range = [animationRange.start, animationRange.end, animationRange.start]
				match.show_match.checked = readValue f
				match.anim_enabled.checked = readValue f
				filter.filt_btns.state = readValue f
				filter.filt_amt.value = readValue f
				filter.re_match.checked = readValue f
				-- load trackers
				local num_trackers = readValue f, k
				if num_trackers > 0 then
				(
					for i in 1 to num_trackers do
					(
						-- load tracker
						t = tracker ()
						append trackers t
						t.index = trackers.count
						t.track_obj_name = readValue f
						t.track_obj = if t.track_obj_name != undefined then execute t.track_obj_name else undefined
						t.start_frame = readValue f
						t.end_frame = readValue f
						t.enabled = readValue f
						t.match_weight = readValue f
						t.resample = readValue f
						t.subpixel_level = readValue f
						t.path = #()
						local num_positions = readValue f
						if num_positions > 0 then
						(
							-- load tracker path
							for i in 1 to num_positions do
							(
								local c = readChar f
								if c == "k" then
								(
									-- keyframe
									k = key_frame ()
									t.path[i] = k
									k.center = readValue f
									k.f_bounds = readValue f --#(readValue f, readValue f, readValue f, readValue f)
									k.m_bounds = readValue f --#(readValue f, readValue f, readValue f, readValue f)
								)
								else if c == "p" then
									t.path[i] = track_point (readValue f) (readValue f) (readValue f) (readValue f)
								else
									skipToNextLine f
							)
						)

						-- make feature tracker in movie
						mt = CTMotionTracker movie gizmos.tracker_change_handler
						t.gizmo = mt
						setStruct mt t
						if classof (k = t.path[1]) == key_frame then
						(
							mt.center = k.center
							mt.featureBounds = k.f_bounds
							mt.motionBounds = k.m_bounds
							mt.subpixelLevel = t.subpixel_level
							mt.visible = t.enabled
--							resample mt
--							t.cur_keyframe = movie.frame
							t.cur_keyframe = undefined
						)
					)
				)
				-- objmove state
				if version != "0.4b" then
				(
					
					objmove.movie_start.value = readValue f
					objmove.anim_start.value = readValue f
					objmove.frames.value = readValue f
					-- reset to current movie/scene stats
					objmove.movie_start.range = [0, mf, min mf objmove.movie_start.value]
					objmove.frames.range = [0, (min mf animationRange.end)+1, min objmove.frames.value ((min mf animationRange.end)+1)]
					objmove.anim_start.range = [animationRange.start, animationRange.end, animationRange.start]
					objmove.tracker_list.selection = readValue f
					objmove.tracker_selected ()
					local objname = readValue f
					if objname != undefined then objmove.set_pin_obj (execute objname)
					objmove.space.state = readValue f
					objmove.mode.state = readValue f
				)
				
				close f
				return ok
			)
			else
				messageBox "Obsolete .mot file version"
			close f
		)
	)
	
	rollout aboutbox "About"
	(
		label l1 "Developed for Discreet by"
		label l2 "John Wainwright"
		label l3 "Lyric Media"
	)
	
	on camtrack open do  
	(
		-- add rollouts
		addRollout setmovie --rolledUp:true
		addRollout gizmos --rolledUp:true
		addRollout stepper rolledUp:true
		addRollout error rolledUp:true
		addRollout track rolledUp:true
		addRollout posdata rolledUp:true
		addRollout match rolledUp:true
		addRollout filter rolledUp:true
		addRollout objmove rolledUp:true
		addRollout aboutbox rolledUp:true
	)
	
	on camtrack close do
	(
		-- close rollouts
		removeRollout setmovie
		removeRollout gizmos
		removeRollout stepper
		removeRollout error
		removeRollout track
		removeRollout posdata
		removeRollout match
		removeRollout filter 
		removeRollout objmove 
		removeRollout aboutbox
	)
)

-- openUtility camtrack

-- DONE! add sub-pixel bi-cubic upscaling
-- make smoothing, etc. just work on match range
-- need visible tracking lines
-- DONE! mode to keep selected gizmo centered in window during tracking
-- jump error should be by move relative to average of other features, either s or ds/dt
-- DONE!! a facility to set weights for different features in the correlation to set which
--   ones should be more exact at the expense of others
-- finish Pos Data rollout
-- add filmback rubber-banding sizing/placement rectangle (for plates that overdigitize film)
-- add jump to next keyframe, delete keyframe, delete keyframes to end, clear tracking data
-- active/inactive ranges for trackers
-- end-of-tracking report if any trackers error-disabled, indicate what threshold is breaking
--   maybe add checkkbox to control error-disabling

-- add shot-steadying mode in which cam is counter-moved to keep projections still
--   this could come in two forms, one which just processes a movie and outputs a
--   steadied version, another which is used somehow *after* a match move to counter-move images
--   to match moves in cam-matched projection
-- add lens distortion equation and its parameters to solver
-- marker-based tracking
   -- DONE! smoothing panel option should have a single-value average option for fitting
   --     estimated initially, but known fixed parameters. 
-- mem-loader s/b auto phys-mem-based
   -- DONE! match errors don't quit option, probably a query box with continue option
-- make filter amount be cut-off frequency
-- be able to group points as camera stters and others as object movement detectors
-- option to pre-load frames into memory to speed browsing
-- auto-weighting towards center to offset lens edge distortion

-- recommendations about putting features v. near edges of obj to be composited in
-- display feature paths
-- make filter work over match range
-- keyframe reduction
-- pre-delete matching keys
-- delete keys button
-- show match error in panel