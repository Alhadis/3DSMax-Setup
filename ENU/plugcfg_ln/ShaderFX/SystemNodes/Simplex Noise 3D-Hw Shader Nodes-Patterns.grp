SFX_WIN
Version=24
GroupVersion=1.081
Advanced=0
HelpID=79
NumberOfNodes=14
#NT=10100 0
	PC=19
	name=1 v=5000 SimplexNoise3D
	version=1 v=2003 1.081
	posx=1 v=2003 -1009.61
	posy=1 v=2003 64.2466
	previewswatch=1 v=2002 1
	classname=1 v=5000 Simplex Noise 3D
	submenuname=1 v=5000 Patterns
	helpid=1 v=2002 79
	grpnodecolor=1 v=5012 3
	grpPosX=1 v=2003 -765.917
	grpPosY=1 v=2003 32.1941
	uvindex_UVs=2 e=2 v=2002 0
	uvsetname_UVs=2 e=3 v=5000 
	perinstanceunshared_UVs=2 e=4 v=2001 0
	valueX_Tile=2 e=5 v=2003 5.0
	valueY_Tile=2 e=6 v=2003 5.0
	valueX_Offset=2 e=7 v=2003 0.0
	valueY_Offset=2 e=8 v=2003 0.0
	value_Brightness=2 e=10 v=2003 42.0
	group=-1
	ISC=4
		SVT=5001 3001 0 _UV
		SVT=5001 2003 0 Time
		SVT=5001 2003 0 Brightness
		SVT=1001 1002 0 
	OSC=4
		SVT=5001 3001 0 _UV
		CC=1
			C=0 0 0 2 1 2 0
			CPC=0
		SVT=5001 2003 0 Time
		CC=1
			C=0 1 0 11 1 2 0
			CPC=0
		SVT=5001 2003 0 Brightness
		CC=1
			C=0 2 0 9 1 2 0
			CPC=3
			cx=-220.516
			cy=484.185
			cm=1
		SVT=1001 1002 0 
		CC=0
#NT=10101 0
	PC=2
	posx=1 v=2003 675.206
	posy=1 v=2003 -99.8569
	group=0
	ISC=2
		SVT=5001 2003 0 Noise
		SVT=1001 1002 0 
	OSC=2
		SVT=5001 2003 0 Noise
		CC=0
		SVT=1001 1002 0 
		CC=0
#NT=20109 0
	PC=2
	posx=1 v=2003 -242.218
	posy=1 v=2003 -400.959
	group=0
	ISC=2
		SVT=5001 3001 1 
		SVT=5001 3001 2 
	OSC=1
		SVT=5001 3001 3 
		CC=1
			C=2 0 3 4 0 1 0
			CPC=0
#NT=10100 1 UV Set-Hw Shader Nodes-Inputs Common
	PC=14
	name=1 v=5000 _UVSet
	version=1 v=2003 1.69
	posx=1 v=2003 -580.833
	posy=1 v=2003 -417.051
	classname=1 v=5000 UV Set
	submenuname=1 v=5000 Inputs Common
	bitmapnodeindex=1 v=2002 65
	helpid=1 v=2002 23
	grpnodecolor=1 v=5012 5
	grpPosX=1 v=2003 -450.0
	grpPosY=1 v=2003 -221.667
	uvindex_UVs=2 e=2 v=2002 0
	uvsetname_UVs=2 e=3 v=5000 
	perinstanceunshared_UVs=2 e=4 v=2001 0
	group=0
	ISC=4
		SVT=2002 2002 0 
		SVT=5000 5000 0 
		SVT=2001 2001 0 
		SVT=1001 1002 0 
	OSC=3
		SVT=5001 3003 0 _UVWZ
		CC=0
		SVT=5001 3001 0 _UV
		CC=1
			C=3 1 0 2 0 1 0
			CPC=0
		SVT=5001 1002 0 
		CC=0
#NT=20016 0
	PC=2
	posx=1 v=2003 25.5255
	posy=1 v=2003 -295.795
	group=0
	ISC=2
		SVT=5001 3001 1 
		SVT=5001 3001 2 
	OSC=1
		SVT=5001 3001 3 
		CC=1
			C=4 0 3 6 0 1 0
			CPC=0
#NT=20139 0
	PC=5
	name=1 v=5000 Tile
	posx=1 v=2003 -237.237
	posy=1 v=2003 -232.733
	valueX=2 e=5 v=2003 5.0
	valueY=2 e=6 v=2003 5.0
	group=0
	ISC=0
	OSC=1
		SVT=5001 3001 1 
		CC=1
			C=5 0 1 4 1 2 0
			CPC=0
#NT=20026 0
	PC=2
	posx=1 v=2003 246.246
	posy=1 v=2003 -240.24
	group=0
	ISC=2
		SVT=5001 3001 1 
		SVT=5001 3001 2 
	OSC=1
		SVT=5001 3001 3 
		CC=1
			C=6 0 3 10 2 99 0
			CPC=0
#NT=20139 0
	PC=5
	name=1 v=5000 Offset
	posx=1 v=2003 36.036
	posy=1 v=2003 -117.117
	valueX=2 e=7 v=2003 0.0
	valueY=2 e=8 v=2003 0.0
	group=0
	ISC=0
	OSC=1
		SVT=5001 3001 1 
		CC=1
			C=7 0 1 6 1 2 0
			CPC=0
#NT=20017 0
	PC=4
	name=1 v=5000 Brightness
	posx=1 v=2003 -43.5435
	posy=1 v=2003 522.522
	value=2 e=10 v=2003 42.0
	group=0
	ISC=0
	OSC=1
		SVT=5001 2003 1 
		CC=1
			C=8 0 1 9 0 1 0
			CPC=0
#NT=20109 0
	PC=2
	posx=1 v=2003 205.706
	posy=1 v=2003 537.537
	group=0
	ISC=2
		SVT=5001 2003 1 
		SVT=5001 2003 2 
	OSC=1
		SVT=5001 2003 3 
		CC=1
			C=9 0 3 10 4 101 0
			CPC=0
#NT=20161 0
	PC=4
	posx=1 v=2003 445.152
	posy=1 v=2003 45.8084
	funcname=1 v=5000 SimplexNoise3D
	text=1 v=5000 // Original by: Ian McEwan, Ashima Arts.\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file: http://opensource.org/licenses/MIT\n//               https://github.com/ashima/webgl-noise\n// \n\nfloat3 SimplexNoise3D_mod289(float3 x) \n{\n\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nfloat4 SimplexNoise3D_mod289(float4 x) \n{\n\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nfloat4 SimplexNoise3D_permute(float4 x) \n{\n\treturn SimplexNoise3D_mod289(((x*34.0)+1.0)*x);\n}\n\nfloat4 SimplexNoise3D_taylorInvSqrt(float4 r)\n{\n\treturn 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat SimplexNoise3D_snoise(float3 v, float brightness)\n{ \n\tconst float2  C = float2(1.0/6.0, 1.0/3.0) ;\n\tconst float4  D = float4(0.0, 0.5, 1.0, 2.0);\n\n\t// First corner\n\tfloat3 i  = floor(v + dot(v, C.yyy) );\n\tfloat3 x0 =   v - i + dot(i, C.xxx) ;\n\n\t// Other corners\n\tfloat3 g = step(x0.yzx, x0.xyz);\n\tfloat3 l = 1.0 - g;\n\tfloat3 i1 = min( g.xyz, l.zxy );\n\tfloat3 i2 = max( g.xyz, l.zxy );\n\n\t//   x0 = x0 - 0.0 + 0.0 * C.xxx;\n\t//   x1 = x0 - i1  + 1.0 * C.xxx;\n\t//   x2 = x0 - i2  + 2.0 * C.xxx;\n\t//   x3 = x0 - 1.0 + 3.0 * C.xxx;\n\tfloat3 x1 = x0 - i1 + C.xxx;\n\tfloat3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n\tfloat3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n\t// Permutations\n\ti = SimplexNoise3D_mod289(i); \n\tfloat4 p = SimplexNoise3D_permute( SimplexNoise3D_permute( SimplexNoise3D_permute( \n\t\t\t\ti.z + float4(0.0, i1.z, i2.z, 1.0 ))\n\t\t\t+ i.y + float4(0.0, i1.y, i2.y, 1.0 )) \n\t\t\t+ i.x + float4(0.0, i1.x, i2.x, 1.0 ));\n\n\t// Gradients: 7x7 points over a square, mapped onto an octahedron.\n\t// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n\tfloat n_ = 0.142857142857; // 1.0/7.0\n\tfloat3  ns = n_ * D.wyz - D.xzx;\n\n\tfloat4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n\tfloat4 x_ = floor(j * ns.z);\n\tfloat4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n\tfloat4 x = x_ *ns.x + ns.yyyy;\n\tfloat4 y = y_ *ns.x + ns.yyyy;\n\tfloat4 h = 1.0 - abs(x) - abs(y);\n\n\tfloat4 b0 = float4( x.xy, y.xy );\n\tfloat4 b1 = float4( x.zw, y.zw );\n\n\t//float4 s0 = float4(lessThan(b0,0.0))*2.0 - 1.0;\n\t//float4 s1 = float4(lessThan(b1,0.0))*2.0 - 1.0;\n\tfloat4 s0 = floor(b0)*2.0 + 1.0;\n\tfloat4 s1 = floor(b1)*2.0 + 1.0;\n\tfloat4 sh = -step(h, float4(0,0,0,0));\n\n\tfloat4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n\tfloat4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n\tfloat3 p0 = float3(a0.xy,h.x);\n\tfloat3 p1 = float3(a0.zw,h.y);\n\tfloat3 p2 = float3(a1.xy,h.z);\n\tfloat3 p3 = float3(a1.zw,h.w);\n\n\t//Normalise gradients\n\tfloat4 norm = SimplexNoise3D_taylorInvSqrt(float4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n\tp0 *= norm.x;\n\tp1 *= norm.y;\n\tp2 *= norm.z;\n\tp3 *= norm.w;\n\n\t// Mix final noise value\n\tfloat4 m = max(0.6 - float4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n\tm = m * m;\n\treturn brightness * dot( m*m, float4( dot(p0,x0), dot(p1,x1), \n\t\t\t\t\t\t\t\tdot(p2,x2), dot(p3,x3) ) );\n}\n\nstruct SimplexNoise3DOutput \n{ \n\tfloat noise; \n}; \n\nSimplexNoise3DOutput SimplexNoise3DFunc( float2 UV, float W, float brightness  ) \n{ \n\tSimplexNoise3DOutput OUT; \n\tOUT.noise = SimplexNoise3D_snoise( float3(UV, W), brightness);\n\treturn OUT; \n} \n
	group=0
	ISC=5
		SVT=5001 5011 1 
		SVT=5001 5013 2 
		SVT=5001 3001 99 UV
		SVT=5001 2003 100 W
		SVT=5001 2003 101 brightness
	OSC=1
		SVT=5001 2003 999 noise
		CC=1
			C=10 0 999 1 0 0 0
			CPC=0
#NT=20109 0
	PC=2
	posx=1 v=2003 31.5315
	posy=1 v=2003 102.102
	group=0
	ISC=2
		SVT=5001 2003 1 
		SVT=5001 2003 2 
	OSC=1
		SVT=5001 2003 3 
		CC=1
			C=11 0 3 10 3 100 0
			CPC=0
#NT=20086 0
	PC=2
	posx=1 v=2003 -210.21
	posy=1 v=2003 70.5705
	group=0
	ISC=0
	OSC=1
		SVT=5001 2003 1 
		CC=1
			C=12 0 1 11 0 1 0
			CPC=0
#NT=20175 0
	PC=3
	posx=1 v=2003 -444.0
	posy=1 v=2003 296.0
	text=1 v=5000 // Original by: Ian McEwan, Ashima Arts.\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file: http://opensource.org/licenses/MIT\n//               https://github.com/ashima/webgl-noise\n// \n\ncolor SimplexNoise3D_mod289(color x) \n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nfloat SimplexNoise3D_mod289(float x) \n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nfloat SimplexNoise3D_permute(float x) \n{\n    return SimplexNoise3D_mod289(((x*34.0)+1.0)*x);\n}\n\nfloat SimplexNoise3D_taylorInvSqrt(float r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat S_Dot4(\n    float v1_x, float v1_y, float v1_z, float v1_a,\n    float v2_x, float v2_y, float v2_z, float v2_a\n)\n{\n    return (v1_x * v2_x + v1_y * v2_y + v1_z * v2_z + v1_a * v2_a);\n}\n\nfloat SimplexNoise3D_snoise(color v, float brightness)\n{ \n    v[0] = v[0] * 5;\n    v[1] = v[1] * 5;\n    v[2] = v[2] * 5;\n\n    color C = color(1.0/6.0, 1.0/3.0, 0);\n    float D_x = 0.0;\n    float D_y = 0.5;\n    float D_z = 1.0;\n    float D_a = 2.0;\n\n    // First corner\n    color i  = floor(v + dot(point(v), point(C[1])) );\n    color x0 =   v - i + dot(point(i), point(C[0]))  ;\n\n    // Other corners\n    color g = step(color(x0[1], x0[2], x0[0]), color(x0[0], x0[1], x0[2]));\n\n    color l = 1.0 - g;\n    color i1 = min( g, color(l[2], l[0], l[1]) );\n    color i2 = max( g, color(l[2], l[0], l[1]) );\n\n    color x1 = x0 - i1 + color(C[0]);\n    color x2 = x0 - i2 + color(C[1]); // 2.0*C[0] = 1/3 = C[1]\n    color x3 = x0 - color(D_y);         // -1.0+3.0*C[0] = -0.5 = -D[1]\n\n    // Permutations\n    i = SimplexNoise3D_mod289(i); \n\n    float p_x = SimplexNoise3D_permute( SimplexNoise3D_permute( SimplexNoise3D_permute( \n              i[2] + float(0.0))\n            + i[1] + float(0.0)) \n            + i[0] + float(0.0));\n\n    float p_y = SimplexNoise3D_permute( SimplexNoise3D_permute( SimplexNoise3D_permute( \n              i[2] + float(i1[2]))\n            + i[1] + float(i1[1])) \n            + i[0] + float(i1[0]));\n\n    float p_z = SimplexNoise3D_permute( SimplexNoise3D_permute( SimplexNoise3D_permute( \n              i[2] + float(i2[2]))\n            + i[1] + float(i2[1])) \n            + i[0] + float(i2[0]));\n\n    float p_a = SimplexNoise3D_permute( SimplexNoise3D_permute( SimplexNoise3D_permute( \n              i[2] + float(1.0))\n            + i[1] + float(1.0)) \n            + i[0] + float(1.0));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    color ns = n_ * color(D_a, D_y, D_z) - color(D_x, D_z, D_x);\n\n    float j_x = p_x - 49.0 * floor(p_x* ns[2] * ns[2]);  //  mod(p,7*7)\n    float j_y = p_y - 49.0 * floor(p_y* ns[2] * ns[2]);  //  mod(p,7*7)\n    float j_z = p_z - 49.0 * floor(p_z* ns[2] * ns[2]);  //  mod(p,7*7)\n    float j_a = p_a - 49.0 * floor(p_a* ns[2] * ns[2]);  //  mod(p,7*7)\n\n    float x__x = floor(j_x * ns[2]);\n    float x__y = floor(j_y * ns[2]);\n    float x__z = floor(j_z * ns[2]);\n    float x__a = floor(j_a * ns[2]);\n\n    float y__x = floor(j_x - 7.0 * x__x );    // mod(j,N)\n    float y__y = floor(j_y - 7.0 * x__y );    // mod(j,N)\n    float y__z = floor(j_z - 7.0 * x__z );    // mod(j,N)\n    float y__a = floor(j_a - 7.0 * x__a );    // mod(j,N)\n\n    float x_x = x__x * ns[0] + ns[1];\n    float x_y = x__y * ns[0] + ns[1];\n    float x_z = x__z * ns[0] + ns[1];\n    float x_a = x__a * ns[0] + ns[1];\n\n    float y_x = y__x * ns[0] + ns[1];\n    float y_y = y__y * ns[0] + ns[1];\n    float y_z = y__z * ns[0] + ns[1];\n    float y_a = y__a * ns[0] + ns[1];\n\n    float h_x = 1.0 - abs(x_x) - abs(y_x);\n    float h_y = 1.0 - abs(x_y) - abs(y_y);\n    float h_z = 1.0 - abs(x_z) - abs(y_z);\n    float h_a = 1.0 - abs(x_a) - abs(y_a);\n\n    float b0_x = x_x;\n    float b0_y = x_y;\n    float b0_z = x_x;\n    float b0_a = x_y;\n\n    float b1_x = x_z;\n    float b1_y = x_a;\n    float b1_z = x_z;\n    float b1_a = x_a;\n\n    float s0_x = floor(b0_x)*2.0 + 1.0;\n    float s0_y = floor(b0_y)*2.0 + 1.0;\n    float s0_z = floor(b0_z)*2.0 + 1.0;\n    float s0_a = floor(b0_a)*2.0 + 1.0;\n\n    float s1_x = floor(b1_x)*2.0 + 1.0;\n    float s1_y = floor(b1_y)*2.0 + 1.0;\n    float s1_z = floor(b1_z)*2.0 + 1.0;\n    float s1_a = floor(b1_a)*2.0 + 1.0;\n\n    float sh_x = -step(h_x, 0);\n    float sh_y = -step(h_y, 0);\n    float sh_z = -step(h_z, 0);\n    float sh_a = -step(h_a, 0);\n\n    float a0_x = b0_x + s0_x * sh_x;\n    float a0_y = b0_z + s0_z * sh_x;\n    float a0_z = b0_y + s0_y * sh_y;\n    float a0_a = b0_a + s0_a * sh_y;\n\n    float a1_x = b1_x + s1_x * sh_z;\n    float a1_y = b1_z + s1_z * sh_z;\n    float a1_z = b1_y + s1_y * sh_a;\n    float a1_a = b1_a + s1_a * sh_a;\n\n    color p0 = color(a0_x, a0_y, h_x);\n    color p1 = color(a0_z, a0_a, h_y);\n    color p2 = color(a1_x, a1_y, h_z);\n    color p3 = color(a1_z, a1_a, h_a);\n\n    //Normalise gradients\n    float norm_x = SimplexNoise3D_taylorInvSqrt(dot(point(p0), point(p0)));\n    float norm_y = SimplexNoise3D_taylorInvSqrt(dot(point(p1), point(p1)));\n    float norm_z = SimplexNoise3D_taylorInvSqrt(dot(point(p2), point(p2)));\n    float norm_a = SimplexNoise3D_taylorInvSqrt(dot(point(p3), point(p3)));\n\n    p0 *= norm_x;\n    p1 *= norm_y;\n    p2 *= norm_z;\n    p3 *= norm_a;\n\n    // Mix final noise value\n    float x_dot_x = dot(point(x0), point(x0));\n    float x_dot_y = dot(point(x1), point(x1));\n    float x_dot_z = dot(point(x2), point(x2));\n    float x_dot_a = dot(point(x3), point(x3));\n    \n    float m_x = max(0.6 - x_dot_x, 0.0);\n    float m_y = max(0.6 - x_dot_y, 0.0);\n    float m_z = max(0.6 - x_dot_z, 0.0);\n    float m_a = max(0.6 - x_dot_a, 0.0);\n\n    m_x = m_x * m_x;\n    m_y = m_y * m_y;\n    m_z = m_z * m_z;\n    m_a = m_a * m_a;\n    \n    m_x = m_x * m_x;\n    m_y = m_y * m_y;\n    m_z = m_z * m_z;\n    m_a = m_a * m_a;\n   \n    float res_dot = S_Dot4(m_x, m_y, m_z, m_a, dot(point(p0), point(x0)), dot(point(p1), point(x1)), dot(point(p2), point(x2)), dot(point(p3), point(x3)));\n        \n    return Gamma(brightness * res_dot);\n}\n\nfloat SimplexNoise3DFunc(color UV, float W, float brightness) \n{ \n    return SimplexNoise3D_snoise(color(UV[0], UV[1], W), brightness);\n} \n\nSimplexNoise3DFunc( color( [[ INPUT = UV ? u,-v+1, 0 ]] ), [[ INPUT = Time ? 0.0 ]], [[ INPUT = Brightness ? [[PROP = value_Brightness]] ]] )
	group=0
	ISC=0
	OSC=0
