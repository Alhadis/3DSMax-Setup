SFX_WIN
Version=24
GroupVersion=1.06
Advanced=0
HelpID=80
NumberOfNodes=8
#NT=10100 0
	PC=15
	name=1 v=5000 CellularNoise
	version=1 v=2003 1.06
	posx=1 v=2003 -590.725
	posy=1 v=2003 232.833
	previewswatch=1 v=2002 1
	classname=1 v=5000 Cellular Noise
	submenuname=1 v=5000 Patterns
	helpid=1 v=2002 80
	grpnodecolor=1 v=5012 3
	grpPosX=1 v=2003 -611.501
	grpPosY=1 v=2003 -0.791575
	uvindex_UVs=2 e=2 v=2002 0
	uvsetname_UVs=2 e=3 v=5000 
	perinstanceunshared_UVs=2 e=4 v=2001 0
	value_Contrast=2 e=5 v=2003 0.1
	group=-1
	ISC=3
		SVT=5001 3001 0 _UV
		SVT=5001 2003 0 Contrast
		SVT=1001 1002 0 
	OSC=3
		SVT=5001 3001 0 _UV
		CC=1
			C=0 0 0 5 1 2 0
			CPC=0
		SVT=5001 2003 0 Contrast
		CC=1
			C=0 1 0 6 1 2 0
			CPC=0
		SVT=1001 1002 0 
		CC=0
#NT=10101 0
	PC=2
	posx=1 v=2003 483.178
	posy=1 v=2003 70.2946
	group=0
	ISC=2
		SVT=5001 2003 0 Noise
		SVT=1001 1002 0 
	OSC=2
		SVT=5001 2003 0 Noise
		CC=1
			C=1 0 0 -1 0 1 0
			CPC=0
		SVT=1001 1002 0 
		CC=0
#NT=10100 1 UV Set-Hw Shader Nodes-Inputs Common
	PC=14
	name=1 v=5000 _UVSet
	version=1 v=2003 1.69
	posx=1 v=2003 -309.806
	posy=1 v=2003 -268.184
	classname=1 v=5000 UV Set
	submenuname=1 v=5000 Inputs Common
	bitmapnodeindex=1 v=2002 65
	helpid=1 v=2002 23
	grpnodecolor=1 v=5012 5
	grpPosX=1 v=2003 -450.0
	grpPosY=1 v=2003 -221.667
	uvindex_UVs=2 e=2 v=2002 0
	uvsetname_UVs=2 e=3 v=5000 
	perinstanceunshared_UVs=2 e=4 v=2001 0
	group=0
	ISC=4
		SVT=2002 2002 0 
		SVT=5000 5000 0 
		SVT=2001 2001 0 
		SVT=1001 1002 0 
	OSC=3
		SVT=5001 3003 0 _UVWZ
		CC=0
		SVT=5001 3001 0 _UV
		CC=1
			C=2 1 0 5 0 1 0
			CPC=0
		SVT=5001 1002 0 
		CC=0
#NT=20161 0
	PC=5
	name=1 v=5000 CellularNoise
	posx=1 v=2003 146.669
	posy=1 v=2003 42.1096
	funcname=1 v=5000 CellularNoise
	text=1 v=5000 // Cellular noise ("Worley noise") in 2D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details.\n\nfloat CellularNoiseMod(float x, float y)\n{\n\treturn ( x - y * floor(x/y) );\n}\n\nfloat2 CellularNoiseMod(float2 x, float y)\n{\n\treturn ( x - y * floor(x/y) );\n}\n\nfloat3 CellularNoiseMod(float3 x, float y)\n{\n\treturn ( x - y * floor(x/y) );\n}\n\n#if ( defined(SFX_HLSL_3) || defined(SFX_HLSL_5) || defined(SFX_CGFX_3) )\n   #define fract frac\n   #define mod CellularNoiseMod\n#endif\n\n// Permutation polynomial: (34x^2 + x) mod 289\nfloat3 permute(float3 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\n// Cellular noise, returning F1 and F2 in a float2.\n// Standard 3x3 search window for good F1 and F2 values\nfloat2 CellularNoise(float2 P) {\n#define K 0.142857142857 // 1/7\n#define Ko 0.428571428571 // 3/7\n#define jitter 1.0 // Less gives more regular pattern\n\tfloat2 Pi = mod(floor(P), 280.0);\n \tfloat2 Pf = fract(P);\n\tfloat3 oi = float3(-1.0, 0.0, 1.0);\n\tfloat3 of = float3(-0.5, 0.5, 1.5);\n\tfloat3 px = permute(Pi.x + oi);\n\tfloat3 p = permute(px.x + Pi.y + oi); // p11, p12, p13\n\tfloat3 ox = fract(p*K) - Ko;\n\tfloat3 oy = mod(floor(p*K),7.0)*K - Ko;\n\tfloat3 dx = Pf.x + 0.5 + jitter*ox;\n\tfloat3 dy = Pf.y - of + jitter*oy;\n\tfloat3 d1 = dx * dx + dy * dy; // d11, d12 and d13, squared\n\tp = permute(px.y + Pi.y + oi); // p21, p22, p23\n\tox = fract(p*K) - Ko;\n\toy = mod(floor(p*K),7.0)*K - Ko;\n\tdx = Pf.x - 0.5 + jitter*ox;\n\tdy = Pf.y - of + jitter*oy;\n\tfloat3 d2 = dx * dx + dy * dy; // d21, d22 and d23, squared\n\tp = permute(px.z + Pi.y + oi); // p31, p32, p33\n\tox = fract(p*K) - Ko;\n\toy = mod(floor(p*K),7.0)*K - Ko;\n\tdx = Pf.x - 1.5 + jitter*ox;\n\tdy = Pf.y - of + jitter*oy;\n\tfloat3 d3 = dx * dx + dy * dy; // d31, d32 and d33, squared\n\t// Sort out the two smallest distances (F1, F2)\n\tfloat3 d1a = min(d1, d2);\n\td2 = max(d1, d2); // Swap to keep candidates for F2\n\td2 = min(d2, d3); // neither F1 nor F2 are now in d3\n\td1 = min(d1a, d2); // F1 is now in d1\n\td2 = max(d1a, d2); // Swap to keep candidates for F2\n\td1.xy = (d1.x < d1.y) ? d1.xy : d1.yx; // Swap if smaller\n\td1.xz = (d1.x < d1.z) ? d1.xz : d1.zx; // F1 is in d1.x\n\td1.yz = min(d1.yz, d2.yz); // F2 is now not in d2.yz\n\td1.y = min(d1.y, d1.z); // nor in  d1.z\n\td1.y = min(d1.y, d2.x); // F2 is in d1.y, we're done.\n\td1.xy *= 2.0;\n\treturn sqrt(d1.xy);\n}\n\nstruct CellularNoiseOutput \n{ \n\tfloat value; \n}; \n\nCellularNoiseOutput CellularNoiseFunc( float2 UV, float contrast ) \n{ \n\tfloat2 position = UV * 10.0;\n\tfloat2 F = CellularNoise(position);\n\tfloat facets = contrast+(F.y-F.x);\n\n\tCellularNoiseOutput OUT; \n\tOUT.value = facets;\n\treturn OUT; \n} \n
	group=0
	ISC=4
		SVT=5001 5011 1 
		SVT=5001 5013 2 
		SVT=5001 3001 99 UV
		SVT=5001 2003 100 contrast
	OSC=1
		SVT=5001 2003 999 value
		CC=1
			C=3 0 999 1 0 0 0
			CPC=0
#NT=20017 0
	PC=4
	name=1 v=5000 Contrast
	posx=1 v=2003 -358.252
	posy=1 v=2003 160.362
	value=2 e=5 v=2003 0.1
	group=0
	ISC=0
	OSC=1
		SVT=5001 2003 1 
		CC=1
			C=4 0 1 6 0 1 0
			CPC=0
#NT=20109 0
	PC=2
	posx=1 v=2003 -76.0039
	posy=1 v=2003 -176.103
	group=0
	ISC=2
		SVT=5001 3001 1 
		SVT=5001 3001 2 
	OSC=1
		SVT=5001 3001 3 
		CC=1
			C=5 0 3 3 2 99 0
			CPC=0
#NT=20109 0
	PC=2
	posx=1 v=2003 -98.9149
	posy=1 v=2003 84.7463
	group=0
	ISC=2
		SVT=5001 2003 1 
		SVT=5001 2003 2 
	OSC=1
		SVT=5001 2003 3 
		CC=1
			C=6 0 3 3 3 100 0
			CPC=0
#NT=20175 0
	PC=3
	posx=1 v=2003 -242.5
	posy=1 v=2003 287.5
	text=1 v=5000 float C_fract(float x)\n{\n    return x - floor(x);\n}\n\ncolor C_fract(color p)\n{\n    float px = C_fract(p[0]);\n    float py = C_fract(p[1]);\n    float pz = C_fract(p[2]);\n    return color(px, py, pz);\n}\n\nfloat CellularNoiseMod(float x, float y)\n{\n    return ( x - y * floor(x/y) );\n}\n\ncolor CellularNoiseMod(color x, float y)\n{\n    return ( x - y * floor(x/y) );\n}\n\n// Permutation polynomial: (34x^2 + x) mod 289\ncolor C_permute(color x) {\n  return color(CellularNoiseMod((34.0 * x + 1.0) * x, 289.0));\n}\n\ncolor C_SwapXY(color c)\n{\n    return color(c[1], c[0], c[2]);\n}\n\ncolor C_SwapXZ(color c)\n{\n    return color(c[2], c[1], c[0]);\n}\n\n// Cellular noise, returning F1 and F2 in a color.\n// Standard 3x3 search window for good F1 and F2 values\ncolor CellularNoise(color P) {\n    float K = 0.142857142857; // 1/7\n    float Ko = 0.428571428571; // 3/7\n    float jitter = 1.0; // Less gives more regular pattern\n    \n    color Pi = CellularNoiseMod(floor(P), 280.0);\n    color Pf = C_fract(P);\n    color oi = color(-1.0, 0.0, 1.0);\n    color of = color(-0.5, 0.5, 1.5);\n    color px = C_permute(Pi[0] + oi);\n    color p = C_permute(px[0] + Pi[1] + oi); // p11, p12, p13\n    color ox = C_fract(p*K) - Ko;\n    color oy = CellularNoiseMod(floor(p*K),7.0)*K - Ko;\n    color dx = Pf[0] + 0.5 + jitter*ox;\n    color dy = Pf[1] - of + jitter*oy;\n    color d1 = dx * dx + dy * dy; // d11, d12 and d13, squared\n    p = C_permute(px[1] + Pi[1] + oi); // p21, p22, p23\n    ox = C_fract(p*K) - Ko;\n    oy = CellularNoiseMod(floor(p*K),7.0)*K - Ko;\n    dx = Pf[0] - 0.5 + jitter*ox;\n    dy = Pf[1] - of + jitter*oy;\n    color d2 = dx * dx + dy * dy; // d21, d22 and d23, squared\n    p = C_permute(px[2] + Pi[1] + oi); // p31, p32, p33\n    ox = C_fract(p*K) - Ko;\n    oy = CellularNoiseMod(floor(p*K),7.0)*K - Ko;\n    dx = Pf[0] - 1.5 + jitter*ox;\n    dy = Pf[1] - of + jitter*oy;\n    color d3 = dx * dx + dy * dy; // d31, d32 and d33, squared\n    // Sort out the two smallest distances (F1, F2)\n    color d1a = min(d1, d2);\n    d2 = max(d1, d2); // Swap to keep candidates for F2\n    d2 = min(d2, d3); // neither F1 nor F2 are now in d3\n    d1 = min(d1a, d2); // F1 is now in d1\n    d2 = max(d1a, d2); // Swap to keep candidates for F2\n    \n    \n    d1 = (d1[0] < d1[1]) ? d1 : C_SwapXY(d1); // Swap if smaller\n    d1 = (d1[0] < d1[2]) ? d1 : C_SwapXZ(d1); // F1 is in d1[0]\n    d1[1] = min(d1[1], d2[1]);\n    d1[2] = min(d1[2], d2[2]);\n    d1[1] = min(d1[1], d1[2]); // nor in  d1[2]\n    d1[1] = min(d1[1], d2[0]); // F2 is in d1[1], we're done.\n    d1[0] *= 2.0;\n    d1[1] *= 2.0;\n    return sqrt(color(d1[0], d1[1], 0));\n}\n\nfloat CellularNoiseFunc( color UV, float contrast ) \n{ \n    color position = UV * 10.0;\n    color F = CellularNoise(position);\n    float facets = contrast+(F[1]-F[0]);\n\n    return Gamma(facets); \n} \n\nCellularNoiseFunc( [[ INPUT = UV ? color(u,-v+1,0) ]], [[ INPUT = Contrast ? [[PROP=value_Contrast]] ]] )
	group=0
	ISC=0
	OSC=0
